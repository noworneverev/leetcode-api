[
  {
    "data": {
      "question": {
        "questionId": "1",
        "questionFrontendId": "1",
        "title": "Two Sum",
        "content": "<p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>\n\n<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>\n\n<p>You can return the answer in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,4], target = 6\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3], target = 6\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>Only one valid answer exists.</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:&nbsp;</strong>Can you come up with an algorithm that is less than <code>O(n<sup>2</sup>)</code><font face=\"monospace\">&nbsp;</font>time complexity?",
        "likes": 66740,
        "dislikes": 2483,
        "stats": "{\"totalAccepted\": \"20.2M\", \"totalSubmission\": \"35.6M\", \"totalAcceptedRaw\": 20238187, \"totalSubmissionRaw\": 35601424, \"acRate\": \"56.8%\"}",
        "similarQuestions": "[{\"title\": \"3Sum\", \"titleSlug\": \"3sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"4Sum\", \"titleSlug\": \"4sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Two Sum II - Input Array Is Sorted\", \"titleSlug\": \"two-sum-ii-input-array-is-sorted\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Two Sum III - Data structure design\", \"titleSlug\": \"two-sum-iii-data-structure-design\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Subarray Sum Equals K\", \"titleSlug\": \"subarray-sum-equals-k\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Two Sum IV - Input is a BST\", \"titleSlug\": \"two-sum-iv-input-is-a-bst\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Two Sum Less Than K\", \"titleSlug\": \"two-sum-less-than-k\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Max Number of K-Sum Pairs\", \"titleSlug\": \"max-number-of-k-sum-pairs\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Good Meals\", \"titleSlug\": \"count-good-meals\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Number of Pairs With Absolute Difference K\", \"titleSlug\": \"count-number-of-pairs-with-absolute-difference-k\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Number of Pairs of Strings With Concatenation Equal to Target\", \"titleSlug\": \"number-of-pairs-of-strings-with-concatenation-equal-to-target\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find All K-Distant Indices in an Array\", \"titleSlug\": \"find-all-k-distant-indices-in-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"First Letter to Appear Twice\", \"titleSlug\": \"first-letter-to-appear-twice\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Number of Excellent Pairs\", \"titleSlug\": \"number-of-excellent-pairs\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Number of Arithmetic Triplets\", \"titleSlug\": \"number-of-arithmetic-triplets\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Node With Highest Edge Score\", \"titleSlug\": \"node-with-highest-edge-score\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Check Distances Between Same Letters\", \"titleSlug\": \"check-distances-between-same-letters\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Subarrays With Equal Sum\", \"titleSlug\": \"find-subarrays-with-equal-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Largest Positive Integer That Exists With Its Negative\", \"titleSlug\": \"largest-positive-integer-that-exists-with-its-negative\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Number of Distinct Averages\", \"titleSlug\": \"number-of-distinct-averages\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Pairs Whose Sum is Less than Target\", \"titleSlug\": \"count-pairs-whose-sum-is-less-than-target\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions just for completeness. It is from these brute force solutions that you can come up with optimizations.",
          "So, if we fix one of the numbers, say <code>x</code>, we have to scan the entire array to find the next number <code>y</code> which is <code>value - x</code> where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
          "The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n\n---\n\n<div>\n    <div class=\"video-container\">\n        <iframe src=\"https://player.vimeo.com/video/567281997\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n    </div>\n</div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Brute Force\n\n**Algorithm**\n\nThe brute force approach is simple. Loop through each element $$x$$ and find if there is another value that equals to $$target - x$$.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/WTVGRyeD/shared\" frameBorder=\"0\" width=\"100%\" height=\"327\" name=\"WTVGRyeD\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$O(n^2)$$.\nFor each element, we try to find its complement by looping through the rest of the array which takes $$O(n)$$ time. Therefore, the time complexity is $$O(n^2)$$.\n\n* Space complexity: $$O(1)$$.\nThe space required does not depend on the size of the input array, so only constant space is used.\n\n---\n### Approach 2: Two-pass Hash Table\n\n**Intuition**\n\nTo improve our runtime complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to get its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table.\n\nWe can reduce the lookup time from $$O(n)$$ to $$O(1)$$ by trading space for speed. A hash table is well suited for this purpose because it supports fast lookup in *near* constant time. I say \"near\" because if a collision occurred, a lookup could degenerate to $$O(n)$$ time. However, lookup in a hash table should be amortized $$O(1)$$ time as long as the hash function was chosen carefully.\n\n**Algorithm**\n\nA simple implementation uses two iterations. In the first iteration, we add each element's value as a key and its index as a value to the hash table. Then, in the second iteration, we check if each element's complement ($$target - nums[i]$$) exists in the hash table. If it does exist, we return current element's index and its complement's index. Beware that the complement must not be $$nums[i]$$ itself!\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/bbEpXJcf/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"bbEpXJcf\"></iframe>  \n\n**Complexity Analysis**\n\n* Time complexity: $$O(n)$$.\nWe traverse the list containing $$n$$ elements exactly twice. Since the hash table reduces the lookup time to $$O(1)$$, the overall time complexity is $$O(n)$$.\n\n* Space complexity: $$O(n)$$.\nThe extra space required depends on the number of items stored in the hash table, which stores exactly $$n$$ elements.\n\n---\n### Approach 3: One-pass Hash Table\n\n**Algorithm**\n    \nIt turns out we can do it in one-pass. While we are iterating and inserting elements into the hash table, we also look back to check if current element's complement already exists in the hash table. If it exists, we have found a solution and return the indices immediately.\n\n**Implementation**    \n    \n<iframe src=\"https://leetcode.com/playground/4KK3DMtw/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"4KK3DMtw\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$O(n)$$.\nWe traverse the list containing $$n$$ elements only once. Each lookup in the table costs only $$O(1)$$ time.\n\n* Space complexity: $$O(n)$$.\nThe extra space required depends on the number of items stored in the hash table, which stores at most $$n$$ elements."
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/two-sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "2",
        "questionFrontendId": "2",
        "title": "Add Two Numbers",
        "content": "<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum&nbsp;as a linked list.</p>\n\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\" style=\"width: 483px; height: 342px;\" />\n<pre>\n<strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]\n<strong>Output:</strong> [7,0,8]\n<strong>Explanation:</strong> 342 + 465 = 807.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [0], l2 = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n<strong>Output:</strong> [8,9,9,9,0,0,0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>It is guaranteed that the list represents a number that does not have leading zeros.</li>\n</ul>\n",
        "likes": 35926,
        "dislikes": 7122,
        "stats": "{\"totalAccepted\": \"6.6M\", \"totalSubmission\": \"13.9M\", \"totalAcceptedRaw\": 6615517, \"totalSubmissionRaw\": 13879865, \"acRate\": \"47.7%\"}",
        "similarQuestions": "[{\"title\": \"Multiply Strings\", \"titleSlug\": \"multiply-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add Binary\", \"titleSlug\": \"add-binary\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sum of Two Integers\", \"titleSlug\": \"sum-of-two-integers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add Strings\", \"titleSlug\": \"add-strings\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add Two Numbers II\", \"titleSlug\": \"add-two-numbers-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add to Array-Form of Integer\", \"titleSlug\": \"add-to-array-form-of-integer\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add Two Polynomials Represented as Linked Lists\", \"titleSlug\": \"add-two-polynomials-represented-as-linked-lists\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Double a Number Represented as a Linked List\", \"titleSlug\": \"double-a-number-represented-as-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Math"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Elementary Math\n\n**Intuition**\n\nKeep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit.\n\n![Illustration of Adding two numbers](../Figures/2_add_two_numbers.svg){:width=\"539px\"}\n\n\n*Figure 1. Visualization of the addition of two numbers: $$342 + 465 = 807$$.  \nEach node contains a single digit and the digits are stored in reverse order.*\n\n\n**Algorithm**\n\nJust like how you would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of $$l1$$ and $$l2$$. Since each digit is in the range of $$0 \\ldots 9$$, summing two digits may \"overflow\". For example $$5 + 7 = 12$$. In this case, we set the current digit to $$2$$ and bring over the $$carry = 1$$ to the next iteration. $$carry$$ must be either $$0$$ or $$1$$ because the largest possible sum of two digits (including the carry) is $$9 + 9 + 1 = 19$$.\n\nThe pseudocode is as following:\n\n* Initialize current node to dummy head of the returning list.\n* Initialize carry to $$0$$.\n* Loop through lists $$l1$$ and $$l2$$ until you reach both ends and carry is $$0$$.\n    * Set $$x$$ to node $$l1$$'s value. If $$l1$$ has reached the end of $$l1$$, set to $$0$$.\n    * Set $$y$$ to node $$l2$$'s value. If $$l2$$ has reached the end of $$l2$$, set to $$0$$.\n    * Set $$sum = x + y + carry$$.\n    * Update $$carry = sum / 10$$.\n    * Create a new node with the digit value of $$(sum \\bmod 10)$$ and set it to current node's next, then advance current node to next.\n    * Advance both $$l1$$ and $$l2$$.\n* Return dummy head's next node.\n\nNote that we use a dummy head to simplify the code. Without a dummy head, you would have to write extra conditional statements to initialize the head's value.\n\nTake extra caution of the following cases:\n\n| Test case | Explanation |\n| ------------- | ---------------- |\n| $$l1=[0,1]$$<br>$$l2=[0,1,2]$$ | When one list is longer than the other. |\n| $$l1=[]$$<br>$$l2=[0,1]$$ | When one list is null, which means an empty list. |\n| $$l1=[9,9]$$<br>$$l2=[1]$$ | The sum could have an extra carry of one at the end, which is easy to forget. |\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/XsLdm2AA/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"XsLdm2AA\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(\\max(m, n))$$. Assume that $$m$$ and $$n$$ represents the length of $$l1$$ and $$l2$$ respectively, the algorithm above iterates at most $$\\max(m, n)$$ times.\n\n* Space complexity : $$O(1)$$. The length of the new list is at most $$\\max(m,n) + 1$$ However, we don't count the answer as part of the space complexity.\n\n**Follow up**\n\nWhat if the the digits in the linked list are stored in non-reversed order? For example:\n\n$$\n(3 \\to 4 \\to 2) + (4 \\to 6 \\to 5) = 8 \\to 0 \\to 7\n$$"
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/add-two-numbers/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "3",
        "questionFrontendId": "3",
        "title": "Longest Substring Without Repeating Characters",
        "content": "<p>Given a string <code>s</code>, find the length of the <strong>longest</strong> <span data-keyword=\"substring-nonempty\"><strong>substring</strong></span> without duplicate characters.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcabcbb&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The answer is &quot;abc&quot;, with the length of 3. Note that <code>&quot;bca&quot;</code> and <code>&quot;cab&quot;</code> are also correct answers.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bbbbb&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The answer is &quot;b&quot;, with the length of 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pwwkew&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The answer is &quot;wke&quot;, with the length of 3.\nNotice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>\n</ul>\n",
        "likes": 44088,
        "dislikes": 2160,
        "stats": "{\"totalAccepted\": \"8.8M\", \"totalSubmission\": \"23M\", \"totalAcceptedRaw\": 8779056, \"totalSubmissionRaw\": 22969251, \"acRate\": \"38.2%\"}",
        "similarQuestions": "[{\"title\": \"Longest Substring with At Most Two Distinct Characters\", \"titleSlug\": \"longest-substring-with-at-most-two-distinct-characters\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Substring with At Most K Distinct Characters\", \"titleSlug\": \"longest-substring-with-at-most-k-distinct-characters\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Subarrays with K Different Integers\", \"titleSlug\": \"subarrays-with-k-different-integers\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Erasure Value\", \"titleSlug\": \"maximum-erasure-value\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Equal Count Substrings\", \"titleSlug\": \"number-of-equal-count-substrings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Consecutive Cards to Pick Up\", \"titleSlug\": \"minimum-consecutive-cards-to-pick-up\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Nice Subarray\", \"titleSlug\": \"longest-nice-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Optimal Partition of String\", \"titleSlug\": \"optimal-partition-of-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Complete Subarrays in an Array\", \"titleSlug\": \"count-complete-subarrays-in-an-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Longest Special Substring That Occurs Thrice II\", \"titleSlug\": \"find-longest-special-substring-that-occurs-thrice-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Longest Special Substring That Occurs Thrice I\", \"titleSlug\": \"find-longest-special-substring-that-occurs-thrice-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Generate all possible substrings & check for each substring if it's valid and keep updating maxLen accordingly."
        ],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Sliding Window"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "4",
        "questionFrontendId": "4",
        "title": "Median of Two Sorted Arrays",
        "content": "<p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <strong>the median</strong> of the two sorted arrays.</p>\n\n<p>The overall run time complexity should be <code>O(log (m+n))</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,3], nums2 = [2]\n<strong>Output:</strong> 2.00000\n<strong>Explanation:</strong> merged array = [1,2,3] and median is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2], nums2 = [3,4]\n<strong>Output:</strong> 2.50000\n<strong>Explanation:</strong> merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m &lt;= 1000</code></li>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "likes": 31571,
        "dislikes": 3534,
        "stats": "{\"totalAccepted\": \"4M\", \"totalSubmission\": \"8.7M\", \"totalAcceptedRaw\": 3969532, \"totalSubmissionRaw\": 8706009, \"acRate\": \"45.6%\"}",
        "similarQuestions": "[{\"title\": \"Median of a Row Wise Sorted Matrix\", \"titleSlug\": \"median-of-a-row-wise-sorted-matrix\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Divide and Conquer"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n\n---\n <div class='video-preview'></div>\n\n## Solution\n\n--- \n\n### Overview\n\nIn this problem, we are given two **sorted** arrays, `nums1` and `nums2`. We need to return the **median** of these two arrays.\n\n---\n\n### Approach 1: Merge Sort\n\n#### Intuition   \n\nLet's start with the straightforward approach. If we put the elements of two arrays in one array `A` and arrange them in order. Assume the merged arrays has a length of `n`, then the median is:\n    - `A[n / 2]`, if `n` is odd.\n    - The average of `A[n / 2]` and `A[n / 2 + 1]`, if `n` is even.\n\nHowever, we do not really need to merge and sort these arrays. Note that both arrays are already sorted, so the smallest element is either the first element of `nums1` or the first element of `nums2`. Therefore, we can set two pointers `p1` and `p2` at the start of each array, then we can get the smallest element from the `nums1` and `nums2` by comparing the values `nums1[p1]` and `nums2[p2]`.\n\nPlease refer to the following slide as an example:\n\n!?!../Documents/4/s1.json:601,301!?!\n\n\n<br>\n\n#### Algorithm\n\n1) Get the total size of two arrays `m + n`\n    - If `m + n` is odd, we are looking for the `(m + n) / 2`-th element.\n    - If `m + n` is even, we are looking for the average of the `(m + n) / 2`-th and the `(m + n) / 2 + 1`-th elements.\n2) Set two pointers `p1` and `p2` at the beginning of arrays `nums1` and `nums2`. \n3) If both `p1` and `p2` are in bounds of the arrays, compare the values at `p1` and `p2`:\n\n    - If `nums1[p1]` is smaller than `nums2[p2]`, we move `p1` one place to the right.\n    - Otherwise, we move `p2` one place to the right.\n\n    If `p1` is outside `nums1`, just move `p2` one place to the right.     \n    If `p2` is outside `nums2`, just move `p1` one place to the right.\n4) Get the target elements and calculate the median:\n    - If `m + n` is odd, repeat step 3 by `(m + n + 1) / 2` times and return the element from the last step.\n    - If `m + n` is even, repeat step 3 by `(m + n) / 2 + 1` times and return the average of the elements from the last two steps.\n\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/76VATgZB/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"76VATgZB\"></iframe>\n\n\n#### Complexity Analysis\n\nLet $$m$$ be the size of array `nums1` and $$n$$ be the size of array `nums2`.\n\n* Time complexity: $$O(m + n)$$\n\n    - We get the smallest element by comparing two values at `p1` and `p2`, it takes $$O(1)$$ to compare two elements and move the corresponding pointer to the right.\n    - We need to traverse half of the arrays before reaching the median element(s).\n    - To sum up, the time complexity is $$O(m + n)$$.\n    \n\n* Space complexity: $$O(1)$$\n\n    - We only need to maintain two pointers `p1` and `p2`.\n\n<br/>\n\n\n\n---\n\n### Approach 2: Binary Search, Recursive\n\n#### Intuition   \n\nBecause the inputs are sorted arrays and the problem asks for a logarithmic time limit, we strongly feel that binary search (or a similar approach) is a promising method. While we're not sure how to cast the same pattern as a normal binary search on this problem, let's go over some steps of a regular binary search and see if we can get any inspiration. (If you are not familiar with binary search, you can refer to our [Binary Search Explore Card](https://leetcode.com/explore/learn/card/binary-search/))\n\n\nHere we use binary search to find `target` in a sorted array `A`:\n\n- Locate the middle index (element) of `A`.\n- Compare the value of the middle element with `target`.\n- Reduce the search space by cutting the current array in half and discarding the half which is guaranteed not to contain `target`.\n\n- Repeat the above process until we either empty the array (move to half a the length of 0) or find `target`.\n\n\n\n![img](../Figures/4/bs.png)\n\nAt each step, the search space is cut in half, so we can quickly get the result. Now back to this problem where we have two sorted arrays. For the sake of convenience, let's call them `A` and `B`. \n\n![img](../Figures/4/2.png)\n\nSimilarly, we can get and compare their middle values `A_mid` and `B_mid`. Without loss of generality in this example we assume `A_mid <= B_mid` initially, as shown in the yellow boxes. \n\n\n\n![img](../Figures/4/3.png)\n\n**What does this comparison imply?**\n\nIt implies that we can compare sections of `A` and `B`.\n\n> For the rest of this article, we will use $$\\le$$ to represent the relative magnitude of values in arrays. For example, $$A_{\\text{left}} \\le A_{\\text{right}}$$ means that every element in $A_{\\text{left}}$ is no larger than any element in $A_{\\text{right}}$. We also 'compare' elements in an array with a single element similarly, for example, $$A_{\\text{left}} \\le A_{\\text{mid}}$$ means that every element in $A_{\\text{left}}$ is no larger than the element $A_{\\text{mid}}$. \nThis may not be the most standard way of expressing it, but is easy enough to understand.\n\nRecall that both arrays are sorted, so we know that:\n- $$A_{\\text{left}} \\le A_{\\text{mid}}$$\n- $$B_{\\text{mid}} \\le B_{\\text{right}}$$\n\nCombine these observations with the comparison we just made:\n\n\n$$A_{\\text{mid}} \\le B_{\\text{mid}}$$\n\nWe have the following result:\n\n$$A_{\\text{left}} \\le A_{\\text{mid}} \\le B_{\\text{mid}} \\le B_{\\text{right}}$$\n\nThus, \n\n$$A_{\\text{left}} \\le B_{\\text{right}}$$\n\nAs shown in the picture below:\n\n![img](../Figures/4/4.png)\n\nSince `A` is sorted, we know that $$A_{\\text{left}} \\le A_{\\text{right}}$$.\n\n![img](../Figures/4/5.png)\n\n\nNow we know that `A_left` is smaller than two halves: `A_right` and `B_right`. Although we still don't know where exactly these elements are, what we do know is **`A_left` doesn't intersect with `A_right + B_right`**! There is an invisible boundary between the `A_left` segment and the mixed segment `A_right + B_right`. As shown in the picture below, the dashed line divides all sorted elements into two halves.\n\n\n\n![img](../Figures/4/6.png)\n\n\nWe can apply all the same logic to the mixed segment $$A_{\\text{left}}$$ + $$B_{\\text{left}}$$ and $$B_{\\text{right}}$$, which also do not intersect. You can try to prove it yourself as an exercise.\n\n\n![img](../Figures/4/7.png)\n\n\nIt looks somewhat clearer, we have clearly separated some subarrays. How do we continue to leverage this knowledge and use the cut-in-half method repeatedly?\n\n\n\n<br>\n\n**The following step is the most important one.**\n\n\nRemember that we are looking for the median of `sorted A + B` which is one or two target values. We regard the index of the target value in the `sorted(A + B)` as `k`. For example: \n\n- If the lengths of `A` and `B` are `6` and `5`, the target index is `k = (6 + 5 + 1) / 2 = 6`, we shall look for the 6th smallest element. \n\n- If the lengths of `A` and `B` are `6` and `6`, the target indexes are `k = (6 + 6) / 2 = 6` and `k + 1 = 7`, we shall look for the 6th and the 7th smallest elements. \n\n\n\nDepending on whether the total number of elements is odd or even, we need the $$k^{th}$$ (and maybe the $$(k + 1)^{th}$$) elements. What matters is that we set an index `k` at the beginning and we want to find the $$k^{th}$$ smallest element using the Binary Search-like algorithm discussed previously (for convenience, we will discuss only the $$k^{th}$$ element for now).\n\n\n\nHowever, during the Binary Search-like algorithm, we keep removing one half of an array, so the index `k` might not stay unchanged. Suppose we removed `3` elements that are smaller than the original $$k^{th}$$ smallest element, we shall look for the $$(k-3)^{th}$$ smallest element from the **remaining** arrays.\n\n\n![img](../Figures/4/exp_1.png)\n\nMore specifically:\n\nIf `k` is larger than half the total number of elements in `sorted(A + B)`, it means that the $$k^{th}$$ element is in the second (larger) half of `sorted(A + B)`, thus $$A_{\\text{left}}$$ (or $$B_{\\text{left}}$$, the smaller of the two smaller sections according to the comparison) is guaranteed not to contain this element, and we can safely cut this half, and reduce `k` by the length of the removed half.\n\n\nIf `k` is not larger than half the total number of elements in `sorted(A + B)`, it means that the $$k^{th}$$ element is in the first (smaller) half of `sorted(A + B)`, thus $$B_{\\text{right}}$$ (or $$A_{\\text{right}}$$, the larger of the two larger sections according to the comparison) is guaranteed not to contain this element, and we can safely discard it. Note that we don't need to modify `k` this time, since we removed one larger half that doesn't affect the order of the $$k^{th}$$ smallest element.\n\n\n\nWe can continue our search like above in the **remaining** arrays. The long arrow that starts from the bottom and points to the top-left indicates that we are repeating the process. Once we cut off part of either `A` or `B`, we regard the remaining arrays as modified `A` and `B` and restart this algorithm. Note that the following picture represents one case only: we consider the case that `a_value < b_value`, thus we remove either the smaller half of `A` or the larger half of `B`. If the comparison result is `a_value >= b_value`, we shall remove either the smaller half of `B` or the larger half of `A`.\n\n![img](../Figures/4/9.png)\n\n\nThat's it. We cut one of the two arrays in half at each step, so this approach has a logarithmic time complexity which we will discuss in detail later.\n\n\n> One more thing!\n\nIn the previous picture, we repeat all processes using the modified arrays, but this is just for the sake of understanding. We won't create copies of two arrays repeatedly, because that would introduce a linear time complexity at least. Instead, we just treat a part of the original array as the modified array for the next step, so that we can repeat the process on the original array without making any duplication. To do this, we need to maintain four pointers, two pointers for each array, e.g., `a_start` and `a_end` represent an inclusive range `[a_start, a_end]` of `A`.\n\n\n<br>\n\n#### Algorithm\n\nLet's define a function that helps us find the $$k^{th}$$ smallest element from two inclusive ranges `[a_start, a_end]` and `[b_start, b_end]` from arrays `A` and `B`.\n\n\n\n1) If the range (for example, a range of `A`) is empty, in other words `a_start > a_end`, it means all elements in `A` are passed, we just return the `(k - a_start)`-th element from the other array `B`. Vice versa if `b_start > b_end`.\n\n2) Otherwise, get the middle indexes of the two ranges: `a_index = (a_start + a_end) / 2`, `b_index = (b_start + b_end) / 2`.\n3) Get the middle values of the two ranges: `a_value = A[a_index]`, `b_value = B[b_index]`.\n4) Cut one array in half, according to:\n    - If `a_index + b_index < k`, cut one smaller half.\n        - If `a_value < b_value`, cut the smaller half of `A`.\n        - Otherwise, cut the smaller half of `B`.\n    - Otherwise, cut one larger half.\n        - If `b_value < a_value`, cut the larger half of `B`.\n        - Otherwise, cut the larger half of `A`.\n5) Repeat step 1 using the new starting and ending indexes of `A` and `B`.\n\n\nThen we move on to find the median elements, and get the length of both arrays `na = len(A)` and `nb = len(B)`.\n- If the total number of elements in `A` and `B` is odd, we just use the above function to find the middle element, that is `k = (na + nb) / 2`.\n- Otherwise, we use the function to find two middle elements: `k = (na + nb) / 2 - 1` and `k = (na + nb) / 2`, and return their average.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/EykqB3jM/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"EykqB3jM\"></iframe>\n\n\n#### Complexity Analysis\n\nLet $$m$$ be the size of array `nums1` and $$n$$ be the size of array `nums2`.\n\n* Time complexity: $$O(\\log(m \\cdot n))$$\n\n\n    - At each step, we cut one half off from either `nums1` or `nums2`. If one of the arrays is emptied, we can directly get the target from the other array in a constant time. Therefore, the total time spent depends on when one of the arrays is cut into an empty array.\n    - In the worst-case scenario, we may need to cut both arrays before finding the target element.\n    - One of the two arrays is cut in half at each step, thus it takes logarithmic time to empty an array. The time to empty two arrays are independent of each other.\n\n    <br>\n    \n    ![img](../Figures/4/tc.png)\n\n    - Therefore, the time complexity is $$O(\\log m + \\log n)$$.\n     $$O(\\log m + \\log n) = O(\\log (m\\cdot n))$$\n    \n\n* Space complexity: $$O(\\log m + \\log n)$$\n\n    - Similar to the analysis on time complexity, the recursion steps depend on the number of iterations before we cut an array into an empty array. In the worst-case scenario, we need $$O(\\log m + \\log n)$$ recursion steps. \n    - However, during the recursive self-call, we only need to maintain 4 pointers: `a_start`, `a_end`, `b_start` and `b_end`. The last step of the function is to call itself, so if tail call optimization is implemented, the call stack always has $$O(1)$$ records.\n\n    - Please refer to [Tail Call](https://en.wikipedia.org/wiki/Tail_call) for more information on tail call optimization.\n\n<br/>\n\n\n\n---\n\n### Approach 3: A Better Binary Search\n\n\n#### Intuition   \n\nRecall the previous approach where we perform a binary search over the 'merged' array consisting of `nums1` and `nums2`, resulting in a time complexity of $$O(\\log(m \\cdot n))$$. We could further improve the algorithm by performing the binary search only on the smaller array of `nums1` and `nums2`, thus the time complexity is reduced to $$O(\\log(\\min(m, n)))$$.\n\n\nThe main idea is similar to approach 2, where we need to find a point of partition in both arrays such that the maximum of the smaller half is less than or equal to the minimum of the larger half. \n\n\nHowever, instead of partitioning over the merged arrays, we can only focus on partitioning the smaller array (let's call this array `A`). Suppose the partition index is `partitionA`, we specify that the smaller half contains `(m + n + 1) / 2` elements, and we can use this feature to our advantage by directly making `partitionB` equal to `(m + n + 1) / 2 - partitionA`, thus the smaller halves of both arrays always contain a total of `(m + n + 1) / 2` elements, as shown in the picture below.\n\n![img](../Figures/4/2_0.png)\n\nThe next step is to compare these edge elements.\n\n![img](../Figures/4/2_1.png)\n\nIf both `maxLeftA <= minRightB` and `maxLeftB <= minRightA` hold, it means that we have partitioned arrays at the correct place. \n\n- The smaller half consists of two sections `A_left` and `B_left`\n- THe larger half consists of two sections `A_right` and `B_right`\n\nWe just need to find the maximum value from the smaller half as `max(A[maxLeftA], B[maxLeftB])` and the minimum value from the larger half as `min(A[minRightA], B[minRightB])`. The median value depends on these four boundary values and the total length of the input arrays and we can compute it by situation.\n\n![img](../Figures/4/2_2.png)\n\nIf `maxLeftA > minRightB`, it implies that `maxLeftA` is **too large to be in the smaller half** and we should look for a smaller partition value of `A`. \n\n\n![img](../Figures/4/2_3.png)\n\nOtherwise, it denotes that `minRightA` is **too small to be in the larger half** and we should look for a larger partition value of `A`.\n\n![img](../Figures/4/2_4.png)\n\n\n<br>\n\n#### Algorithm\n\n1) Assuming `nums1` to be the smaller array (If `nums2` is smaller, we can swap them). Let `m, n` represent the size of `nums1` and `nums2`, respectively.\n\n2) Define the search space for the partitioning index `partitionA` by setting boundaries as `left = 0` and `right = m`.\n\n3) While `left <= right` holds, do the following.\n\n4) Compute the partition index of `nums1` as `partitionA = (left + right) / 2`. Consequently, the partition index of `nums2` is `(m + n + 1) / 2 - partitionA`.\n\n5) Obtain the edge elements:\n    - Determine the maximum value of the section `A_left` as `maxLeftA = nums1[partitionA - 1]`. If `partitionA - 1 < 0`, set it as `maxLeftA = float(-inf)`.\n    - Determine the minimum value of the section `A_right` as `minRightA = nums1[partitionA]`. If `partitionA >= m`, set it as `minRightA = float(inf)`.\n    - Determine the maximum value of the section `B_left` as `maxLeftB = nums2[partitionB - 1]`. If `partitionB - 1 < 0`, set it as `maxLeftB = float(-inf)`.\n    - Determine the maximum value of the section `B_right` as `minRightB = nums2[partitionB]`. If `partitionB >= n`, set it as `minRightB = float(inf)`.\n\n\n6) Compare and recalculate: Compare `maxLeftA` with `minRightB` and `maxLeftB` with `minRightA`. \n    - If `maxLeftA > minRightB`, it means the `maxLeftA` is too large to be in the smaller half, so we update `right = partitionA - 1` to move to the left half of the search space.\n    - If `maxLeftB > minRightA`, it means that we are too far on the left side for `partitionA` and we need to go to the right half of the search space by updating `left = partitionA + 1`. \n\n    Repeat step 4.\n\n7) When both `maxLeftA <= minRightB` and `maxLeftB <= minRightA` are true:\n    - If `(m + n) % 2 = 0`, the median value is the average of the maximum value of the smaller half and the minimum value of the larger half, given by `answer = (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2`.\n    - Otherwise, the median value is the maximum value of the smaller half, given by `answer = max(maxLeftA, maxLeftB)`.\n\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/4xFHzYdC/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"4xFHzYdC\"></iframe>\n\n\n#### Complexity Analysis\n\nLet $$m$$ be the size of array `nums1` and $$n$$ be the size of array `nums2`.\n\n* Time complexity: $$O(\\log(\\min(m, n)))$$\n\n    - We perform a binary search over the smaller array of size $$\\min(m, n)$$.\n\n* Space complexity: $$O(1)$$\n\n    - The algorithm only requires a constant amount of additional space to store and update a few parameters during the binary search.\n\n<br/>"
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "5",
        "questionFrontendId": "5",
        "title": "Longest Palindromic Substring",
        "content": "<p>Given a string <code>s</code>, return <em>the longest</em> <span data-keyword=\"palindromic-string\"><em>palindromic</em></span> <span data-keyword=\"substring-nonempty\"><em>substring</em></span> in <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;babad&quot;\n<strong>Output:</strong> &quot;bab&quot;\n<strong>Explanation:</strong> &quot;aba&quot; is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cbbd&quot;\n<strong>Output:</strong> &quot;bb&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consist of only digits and English letters.</li>\n</ul>\n",
        "likes": 32110,
        "dislikes": 1976,
        "stats": "{\"totalAccepted\": \"4.4M\", \"totalSubmission\": \"12M\", \"totalAcceptedRaw\": 4440567, \"totalSubmissionRaw\": 11982625, \"acRate\": \"37.1%\"}",
        "similarQuestions": "[{\"title\": \"Shortest Palindrome\", \"titleSlug\": \"shortest-palindrome\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Palindrome Permutation\", \"titleSlug\": \"palindrome-permutation\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Palindrome Pairs\", \"titleSlug\": \"palindrome-pairs\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Palindromic Subsequence\", \"titleSlug\": \"longest-palindromic-subsequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Palindromic Substrings\", \"titleSlug\": \"palindromic-substrings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Non-overlapping Palindrome Substrings\", \"titleSlug\": \"maximum-number-of-non-overlapping-palindrome-substrings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "How can we reuse a previously computed palindrome to compute a larger palindrome?",
          "If \u201caba\u201d is a palindrome, is \u201cxabax\u201d a palindrome? Similarly is \u201cxabay\u201d a palindrome?",
          "Complexity based hint:</br>\r\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation."
        ],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n\n---\n <div class='video-preview'></div>\n\n\n## Solution\n\n---\n\n### Approach 1: Check All Substrings\n\n**Intuition**\n\nWe can start with a brute-force approach. We will simply check if each substring is a palindrome, and take the longest one that is.\n\nFirst, let's talk about how we can check if a given string is a palindrome. This is a classic problem and we can do it using two pointers. If a string is a palindrome, the first character is equal to the last character. The second character is equal to the second last character, and so on.\n\n![Palindrome Check](../Figures/5/1.png)\n\nWe initialize two pointers: one at the start of the string and another at the end of it. We check if the characters at the pointers are equal - if they aren't, we know the string cannot be a palindrome. If they are equal, we move to the next pair of characters by moving the pointers toward each other. We continue until we either find a mismatch or the pointers meet. If the pointers meet, then we have checked all pairs and we know the string is a palindrome.\n\nOne bonus to using this algorithm is that we frequently exit early on strings that are not palindromes. If you had a string of length `1000` and the third and third last characters did not match, we would exit the algorithm after only 3 iterations.\n\nThere's another optimization that we can do. Because the problem wants the longest palindrome, we can start by checking the longest-length substrings and iterate toward the shorter-length substrings. This way, the first time we find a substring that is a palindrome, we can immediately return it as the answer.\n\n**Algorithm**\n\n1. Create a helper method `check(i, j)` to determine if a substring is a palindrome.\n    - To save space, we will not pass the substring itself. Instead, we will pass two indices that represent the substring in question. The first character will be `s[i]` and the last character will be `s[j - 1]`.\n    - In this function, declare two pointers `left = i` and `right = j - 1`.\n    - While `left < right`, do the following steps:\n    - If `s[left] != s[right]`, return `false`.\n    - Otherwise, increment `left` and decrement `right`.\n    - If we get through the while loop, return `true`.\n2. Use a for loop to iterate a variable `length` starting from `s.length` until `1`. This variable represents the length of the substrings we are currently considering.\n3. Use a for loop to iterate a variable `start` starting from `0` until and including `s.length - length`. This variable represents the starting point of the substring we are currently considering.\n4. In each inner loop iteration, we are considering the substring starting at `start` until `start + length`. Pass these values into `check` to see if this substring is a palindrome. If it is, return the substring.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/PMqPSHFX/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"PMqPSHFX\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n^3)$$\n\n    The two nested for loops iterate $$O(n^2)$$ times. We check one substring of length `n`, two substrings of length `n - 1`, three substrings of length `n - 2`, and so on.\n\n    There are `n` substrings of length 1, but we don't check them all since any substring of length 1 is a palindrome, and we will return immediately.\n\n    Therefore, the number of substrings that we check in the worst case is `1 + 2 + 3 + ... + n - 1`. This is the partial sum of [this series](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums) for `n - 1`, which is equal to $$\\frac{n \\cdot (n - 1)}{2} = O(n^2)$$.\n\n    In each iteration of the while loop, we perform a palindrome check. The cost of this check is linear with `n` as well, giving us a time complexity of $$O(n^3)$$.\n\n    Note that this time complexity is in the worst case and has a significant constant divisor that is dropped by big O. Due to the optimizations of checking the longer length substrings first and exiting the palindrome check early if we determine that a substring cannot be a palindrome, the practical runtime of this algorithm is not too bad.\n\n* Space complexity: $$O(1)$$\n\n    We don't count the answer as part of the space complexity. Thus, all we use are a few integer variables. \n    \n<br/>\n\n---\n\n### Approach 2: Dynamic Programming\n\n**Intuition**\n\nLet's say that we knew the substring with inclusive bounds `i, j` was a palindrome. If `s[i - 1] == s[j + 1]`, then we know the substring with inclusive bounds `i - 1, j + 1` must also be a palindrome, and this check can be done in constant time.\n\nWe can flip the direction of this logic as well - if `s[i] == s[j]` and the substring `i + 1, j - 1` is a palindrome, then the substring `i, j` must also be a palindrome.\n\n![DP Example](../Figures/5/2.png)\n\nWe know that all substrings of length 1 are palindromes. From this, we can check if each substring of length 3 is a palindrome using the above fact. We just need to check every `i, j` pair where `j - i = 2`. Once we know all palindromes of length 3, we can use that information to find all palindromes of length 5, and then 7, and so on.\n\nWhat about even-length palindromes? A substring of length 2 is a palindrome if both characters are equal. That is, `i, i + 1` is a palindrome if `s[i] == s[i + 1]`. From this, we can use the earlier logic to find all palindromes of length 4, then 6, and so on.\n\nLet's use a table `dp` with dimensions of `n * n`. `dp[i][j]` is a boolean representing if the substring with inclusive bounds `i, j` is a palindrome. We initialize `dp[i][i] = true` for the substrings of length 1, and then `dp[i][i + 1] = (s[i] == s[i + 1])` for the substrings of length 2.\n\nNow, we need to populate the table. We iterate over all `i, j` pairs, starting with pairs that have a difference of 2 (representing substrings of length 3), then pairs with a difference of 3, then 4, and so on. For each `i, j` pair, we check the condition from earlier:\n\n`s[i] == s[j] && dp[i + 1][j - 1]`\n\nIf this condition is true, then the substring with inclusive bounds `i, j` must be a palindrome. We set `dp[i][j] = true`.\n\nBecause we are starting with the shortest substrings and iterating toward the longest substrings, every time we find a new palindrome, it must be the longest one we have seen so far. We can use this fact to keep track of the answer on the fly.\n\n**Algorithm**\n\n1. Initialize `n = s.length` and a boolean table `dp` with size `n * n`, and all values to `false`.\n2. Initialize `ans = [0, 0]`. This will hold the inclusive bounds of the answer.\n3. Set all `dp[i][i] = true`.\n4. Iterate over all pairs `i, i + 1`. For each one, if `s[i] == s[i + 1]`, then set `dp[i][i + 1] = true` and update `ans = [i, i + 1]`.\n5. Now, we populate the `dp` table. Iterate over `diff` from `2` until `n`. This variable represents the difference `j - i`.\n6. In a nested for loop, iterate over `i` from `0` until `n - diff`.\n    - Set `j = i + diff`.\n    - Check the condition: if `s[i] == s[j] && dp[i + 1][j - 1]`, we found a palindrome.\n    - In that case, set `dp[i][j] = true` and `ans = [i, j]`\n\n7. Retrieve the answer bounds from `ans` as `i, j`. Return the substring of `s` starting at index `i` and ending with index `j`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/VMs3My7i/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"VMs3My7i\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n^2)$$\n\n    We declare an `n * n` table `dp`, which takes $$O(n^2)$$ time. We then populate $$O(n^2)$$ states `i, j` - each state takes $$O(1)$$ time to compute.\n\n* Space complexity: $$O(n^2)$$\n\n    The table `dp` takes $$O(n^2)$$ space.\n    \n<br/>\n\n---\n\n### Approach 3: Expand From Centers\n\n**Intuition**\n\nIn the first approach, the palindrome check cost $$O(n)$$. In the second approach, the palindrome check cost $$O(1)$$. This allowed us to improve the time complexity from $$O(n^3)$$ to $$O(n^2)$$.\n\nThe problem with the second approach is that we **always** iterated over $$O(n^2)$$ states of `i, j`. Can we optimize further to minimize the number of iterations required?\n\nIn the first approach, we implemented a palindrome check using two pointers. We started by checking the first and last characters, then the second and second last characters, and so on.\n\nInstead of starting the pointers at the edges and moving inwards, the same logic can be applied when starting the pointers at the center and moving outwards. A palindrome mirrors around its center. Let's say you had `s = \"racecar\"`. If we start both pointers at the middle (`\"e\"`) and move them away from each other, we can see that at every iteration, the characters match: `e -> c -> a -> r`.\n\nThe previous two approaches focused on the bounds of a substring - `i, j`. There are $$O(n^2)$$ bounds, but only $$O(n)$$ centers. For each index `i`, we can consider odd-length palindromes by starting the pointers at `i, i`. To consider the even length palindromes, we can start the pointers at `i, i + 1`. There are $$n$$ starting points for the odd-length palindromes and $$n - 1$$ starting points for the even-length palindromes - that's $$2n - 1 = O(n)$$ starting points in total.\n\nThis is very promising - we can lower the minimum iterations required if we focus on the centers instead of on the bounds. Let's use a helper method `expand(i, j)` that starts two pointers `left = i` and `right = j`. In this method, we will consider `i, j` as a center. When `i == j`, we are considering odd-length palindromes. When `i != j`, we are considering even-length palindromes. We will expand from the center as far as we can to find the longest palindrome, and then return the length of this palindrome.\n\nLet's say that we have a center `i, i`. We call `expand` and find a length of `length`. What are the bounds of the palindrome? Because we are centered at `i, i`, it means `length` must be odd. If we perform floor division of `length` by 2, we will get the number of characters `dist` on each side of the palindrome. For example, given `s = \"racecar\"`, we have `length = 7` and `dist = 7 / 2 = 3`. There are 3 characters on each side - `\"rac\"` on the left and `\"car\"` on the right. Therefore, we can determine that the bounds of the palindrome are `i - dist, i + dist`.\n\nWhat about a center at `i, i + 1`? `length` must be even now. If we have a palindrome with length `2`, then `length / 2 = 1`, but there are zero characters on each side of the center. We can see that `dist` is too large by 1. Therefore, we will calculate `dist` as `(length / 2) - 1` instead. Now, `dist` correctly represents the number of characters on each side. The bounds of the palindrome are `i - dist, i + 1 + dist`.\n\n**Algorithm**\n\n1. Create a helper method `expand(i, j)` to find the length of the longest palindrome centered at `i, j`.\n    - Set `left = i` and `right = j`.\n    - While `left` and `right` are both in bounds and `s[left] == s[right]`, move the pointers away from each other.\n    - The formula for the length of a substring starting at `left` and ending at `right` is `right - left + 1`.\n    - However, when the while loop ends, it implies `s[left] != s[right]`. Therefore, we need to subtract `2`. Return `right - left - 1`.\n2. Initialize `ans = [0, 0]`. This will hold the inclusive bounds of the answer.\n3. Iterate `i` over all indices of `s`.\n    - Find the length of the longest odd-length palindrome centered at `i`: `oddLength = expand(i, i)`.\n    - If `oddLength` is the greatest length we have seen so far, i.e. `oddLength > ans[1] - ans[0] + 1`, update `ans`.\n    - Find the length of the longest even-length palindrome centered at `i`: `evenLength = expand(i, i + 1)`.\n    - If `evenLength` is the greatest length we have seen so far, update `ans`.\n4. Retrieve the answer bounds from `ans` as `i, j`. Return the substring of `s` starting at index `i` and ending with index `j`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/AFGFqkbR/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"AFGFqkbR\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n^2)$$\n\n    There are $$2n - 1 = O(n)$$ centers. For each center, we call `expand`, which costs up to $$O(n)$$.\n\n    Although the time complexity is the same as in the DP approach, the average/practical runtime of the algorithm is much faster. This is because most centers will not produce long palindromes, so most of the $$O(n)$$ calls to `expand` will cost far less than $$n$$ iterations.\n\n    The worst case scenario is when every character in the string is the same.\n\n* Space complexity: $$O(1)$$\n\n    We don't use any extra space other than a few integers. This is a big improvement on the DP approach.\n    \n<br/>\n\n---\n\n### Approach 4: Manacher's Algorithm\n\nBelieve it or not, this problem can be solved in linear time.\n\n[Manacher's algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) finds the longest palindromic substring in $$O(n)$$ time and space.\n\nNote: this algorithm is completely out of scope for coding interviews. Because of this, we will not be talking about the algorithm in detail. This approach has been included for the sake of completeness and for those who are curious about algorithms beyond the scope of interviews.\n\nIf you wish to learn more about Manacher's algorithm, please reference the above link.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/8Zsn7Mso/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"8Zsn7Mso\"></iframe>\n\n**Complexity Analysis**\n\nGiven $$n$$ as the length of `s`,\n\n* Time complexity: $$O(n)$$\n\n    From Wikipedia (the implementation they describe is slightly different from the above code, but it's the same algorithm):\n\n    > The algorithm runs in linear time. This can be seen by noting that Center strictly increases after each outer loop and the sum Center + Radius is non-decreasing. Moreover, the number of operations in the first inner loop is linear in the increase of the sum Center + Radius while the number of operations in the second inner loop is linear in the increase of Center. Since Center $$\\leq$$ 2n+1 and Radius $$\\leq$$ n, the total number of operations in the first and second inner loops is $$O(n)$$ and the total number of operations in the outer loop, other than those in the inner loops, is also $$O(n)$$. The overall running time is therefore $$O(n)$$.\n\n* Space complexity: $$O(n)$$\n\n    We use `sPrime` and `palindromeRadii`, both of length $$O(n)$$.\n    \n<br/>\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/longest-palindromic-substring/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "6",
        "questionFrontendId": "6",
        "title": "Zigzag Conversion",
        "content": "<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>\n\n<pre>\nP   A   H   N\nA P L S I I G\nY   I   R\n</pre>\n\n<p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p>\n\n<p>Write the code that will take a string and make this conversion given a number of rows:</p>\n\n<pre>\nstring convert(string s, int numRows);\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;PAYPALISHIRING&quot;, numRows = 3\n<strong>Output:</strong> &quot;PAHNAPLSIIGYIR&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;PAYPALISHIRING&quot;, numRows = 4\n<strong>Output:</strong> &quot;PINALSIGYAHRPI&quot;\n<strong>Explanation:</strong>\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;A&quot;, numRows = 1\n<strong>Output:</strong> &quot;A&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consists of English letters (lower-case and upper-case), <code>&#39;,&#39;</code> and <code>&#39;.&#39;</code>.</li>\n\t<li><code>1 &lt;= numRows &lt;= 1000</code></li>\n</ul>\n",
        "likes": 9133,
        "dislikes": 15786,
        "stats": "{\"totalAccepted\": \"2.1M\", \"totalSubmission\": \"3.9M\", \"totalAcceptedRaw\": 2059322, \"totalSubmissionRaw\": 3868906, \"acRate\": \"53.2%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/zigzag-conversion/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "7",
        "questionFrontendId": "7",
        "title": "Reverse Integer",
        "content": "<p>Given a signed 32-bit integer <code>x</code>, return <code>x</code><em> with its digits reversed</em>. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>, then return <code>0</code>.</p>\n\n<p><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 123\n<strong>Output:</strong> 321\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = -123\n<strong>Output:</strong> -321\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 120\n<strong>Output:</strong> 21\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= x &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 15143,
        "dislikes": 13946,
        "stats": "{\"totalAccepted\": \"4.7M\", \"totalSubmission\": \"15M\", \"totalAcceptedRaw\": 4687864, \"totalSubmissionRaw\": 14974696, \"acRate\": \"31.3%\"}",
        "similarQuestions": "[{\"title\": \"String to Integer (atoi)\", \"titleSlug\": \"string-to-integer-atoi\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Reverse Bits\", \"titleSlug\": \"reverse-bits\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"A Number After a Double Reversal\", \"titleSlug\": \"a-number-after-a-double-reversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Number of Distinct Integers After Reverse Operations\", \"titleSlug\": \"count-number-of-distinct-integers-after-reverse-operations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Pop and Push Digits & Check before Overflow\n\n**Intuition**\n\nWe can build up the reverse integer one digit at a time.\nWhile doing so, we can check beforehand whether or not appending another digit would cause overflow.\n\n**Algorithm**\n\nReversing an integer can be done similarly to reversing a string.\n\nWe want to repeatedly \"pop\" the last digit off of $$x$$ and \"push\" it to the back of the $$\\text{rev}$$. In the end, $$\\text{rev}$$ will be the reverse of the $$x$$.\n\nTo \"pop\" and \"push\" digits without the help of some auxiliary stack/array, we can use math.\n\n```cpp\n// pop operation:\npop = x % 10;\nx /= 10;\n\n// push operation:\ntemp = rev * 10 + pop;\nrev = temp;\n```\n\nHowever, this approach is dangerous, because the statement $$\\text{temp} = \\text{rev} \\cdot 10 + \\text{pop}$$ can cause overflow.\n\nLuckily, it is easy to check beforehand whether or this statement would cause an overflow.\n\nTo explain, lets assume that $$\\text{rev}$$ is positive.\n\n1. If $$temp = \\text{rev} \\cdot 10 + \\text{pop}$$ causes overflow, then it must be that $$\\text{rev} \\geq \\frac{INTMAX}{10}$$\n2. If $$\\text{rev} > \\frac{INTMAX}{10}$$, then $$temp = \\text{rev} \\cdot 10 + \\text{pop}$$ is guaranteed to overflow.\n3. If $$\\text{rev} == \\frac{INTMAX}{10}$$, then $$temp = \\text{rev} \\cdot 10 + \\text{pop}$$ will overflow if and only if $$\\text{pop} > 7$$\n\nSimilar logic can be applied when $$\\text{rev}$$ is negative.\n\n<iframe src=\"https://leetcode.com/playground/fm5j6WLP/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"fm5j6WLP\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$O(\\log(x))$$. There are roughly $$\\log_{10}(x)$$ digits in $$x$$.\n* Space Complexity: $$O(1)$$."
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/reverse-integer/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "8",
        "questionFrontendId": "8",
        "title": "String to Integer (atoi)",
        "content": "<p>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer.</p>\n\n<p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p>\n\n<ol>\n\t<li><strong>Whitespace</strong>: Ignore any leading whitespace (<code>&quot; &quot;</code>).</li>\n\t<li><strong>Signedness</strong>: Determine the sign by checking if the next character is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>, assuming positivity if neither present.</li>\n\t<li><strong>Conversion</strong>: Read the integer by skipping leading zeros&nbsp;until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.</li>\n\t<li><strong>Rounding</strong>: If the integer is out of the 32-bit signed integer range <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>, then round the integer to remain in the range. Specifically, integers less than <code>-2<sup>31</sup></code> should be rounded to <code>-2<sup>31</sup></code>, and integers greater than <code>2<sup>31</sup> - 1</code> should be rounded to <code>2<sup>31</sup> - 1</code>.</li>\n</ol>\n\n<p>Return the integer as the final result.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;42&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">42</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: &quot;42&quot; (no characters read because there is no leading whitespace)\n         ^\nStep 2: &quot;42&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)\n         ^\nStep 3: &quot;<u>42</u>&quot; (&quot;42&quot; is read in)\n           ^\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot; -042&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">-42</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\nStep 1: &quot;<u>   </u>-042&quot; (leading whitespace is read and ignored)\n            ^\nStep 2: &quot;   <u>-</u>042&quot; (&#39;-&#39; is read, so the result should be negative)\n             ^\nStep 3: &quot;   -<u>042</u>&quot; (&quot;042&quot; is read in, leading zeros ignored in the result)\n               ^\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;1337c0d3&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1337</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\nStep 1: &quot;1337c0d3&quot; (no characters read because there is no leading whitespace)\n         ^\nStep 2: &quot;1337c0d3&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)\n         ^\nStep 3: &quot;<u>1337</u>c0d3&quot; (&quot;1337&quot; is read in; reading stops because the next character is a non-digit)\n             ^\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;0-1&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\nStep 1: &quot;0-1&quot; (no characters read because there is no leading whitespace)\n         ^\nStep 2: &quot;0-1&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)\n         ^\nStep 3: &quot;<u>0</u>-1&quot; (&quot;0&quot; is read in; reading stops because the next character is a non-digit)\n          ^\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 5:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;words and 987&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Reading stops at the first non-digit character &#39;w&#39;.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), <code>&#39; &#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;.&#39;</code>.</li>\n</ul>\n",
        "likes": 6000,
        "dislikes": 15393,
        "stats": "{\"totalAccepted\": \"2.3M\", \"totalSubmission\": \"11.3M\", \"totalAcceptedRaw\": 2291146, \"totalSubmissionRaw\": 11253259, \"acRate\": \"20.4%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Integer\", \"titleSlug\": \"reverse-integer\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Valid Number\", \"titleSlug\": \"valid-number\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Check if Numbers Are Ascending in a Sentence\", \"titleSlug\": \"check-if-numbers-are-ascending-in-a-sentence\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/string-to-integer-atoi/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "9",
        "questionFrontendId": "9",
        "title": "Palindrome Number",
        "content": "<p>Given an integer <code>x</code>, return <code>true</code><em> if </em><code>x</code><em> is a </em><span data-keyword=\"palindrome-integer\"><em><strong>palindrome</strong></em></span><em>, and </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 121\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 121 reads as 121 from left to right and from right to left.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = -121\n<strong>Output:</strong> false\n<strong>Explanation:</strong> From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 10\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Reads 01 from right to left. Therefore it is not a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= x &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without converting the integer to a string?",
        "likes": 15409,
        "dislikes": 2901,
        "stats": "{\"totalAccepted\": \"7.6M\", \"totalSubmission\": \"12.6M\", \"totalAcceptedRaw\": 7554473, \"totalSubmissionRaw\": 12571964, \"acRate\": \"60.1%\"}",
        "similarQuestions": "[{\"title\": \"Palindrome Linked List\", \"titleSlug\": \"palindrome-linked-list\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Palindrome With Fixed Length\", \"titleSlug\": \"find-palindrome-with-fixed-length\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Strictly Palindromic Number\", \"titleSlug\": \"strictly-palindromic-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"  Count Symmetric Integers\", \"titleSlug\": \"count-symmetric-integers\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Count of Good Integers\", \"titleSlug\": \"find-the-count-of-good-integers\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Find the Largest Palindrome Divisible by K\", \"titleSlug\": \"find-the-largest-palindrome-divisible-by-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Beware of overflow when you reverse the integer."
        ],
        "topicTags": [
          {
            "name": "Math"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/palindrome-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "10",
        "questionFrontendId": "10",
        "title": "Regular Expression Matching",
        "content": "<p>Given an input string <code>s</code>&nbsp;and a pattern <code>p</code>, implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code> where:</p>\n\n<ul>\n\t<li><code>&#39;.&#39;</code> Matches any single character.\u200b\u200b\u200b\u200b</li>\n\t<li><code>&#39;*&#39;</code> Matches zero or more of the preceding element.</li>\n</ul>\n\n<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;a&quot; does not match the entire string &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;, p = &quot;.*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length&nbsp;&lt;= 20</code></li>\n\t<li><code>1 &lt;= p.length&nbsp;&lt;= 20</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n\t<li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and&nbsp;<code>&#39;*&#39;</code>.</li>\n\t<li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li>\n</ul>\n",
        "likes": 13172,
        "dislikes": 2374,
        "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"4.3M\", \"totalAcceptedRaw\": 1310720, \"totalSubmissionRaw\": 4337045, \"acRate\": \"30.2%\"}",
        "similarQuestions": "[{\"title\": \"Wildcard Matching\", \"titleSlug\": \"wildcard-matching\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n### Approach 1: Recursion\n\n**Intuition**\n\nIf there were no Kleene stars (the `*` wildcard character for regular expressions), the problem would be easier - we simply check from left to right if each character of the text matches the pattern.\n\nWhen a star is present, we may need to check many different suffixes of the text and see if they match the rest of the pattern.  A recursive solution is a straightforward way to represent this relationship.\n\n**Algorithm**\n\nWithout a Kleene star, our solution would look like this:\n\n\n<iframe src=\"https://leetcode.com/playground/WHCkKfaZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"140\" name=\"WHCkKfaZ\"></iframe>\n\nIf a star is present in the pattern, it will be in the second position $$\\text{pattern[1]}$$.  Then, we may ignore this part of the pattern, or delete a matching character in the text.  If we have a match on the remaining strings after any of these operations, then the initial inputs matched.\n\n<iframe src=\"https://leetcode.com/playground/QZA8SsdJ/shared\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"QZA8SsdJ\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: Let $$T, P$$ be the lengths of the text and the pattern respectively.  In the worst case, a call to `match(text[i:], pattern[2j:])` will be made $$\\binom{i+j}{i}$$ times, and strings of the order $$O(T - i)$$ and $$O(P - 2*j)$$ will be made.  Thus, the complexity has the order $$\\sum_{i = 0}^T \\sum_{j = 0}^{P/2} \\binom{i+j}{i} O(T+P-i-2j)$$.  With some effort outside the scope of this article, we can show this is bounded by $$O\\big((T+P)2^{T + \\frac{P}{2}}\\big)$$.\n\n* Space Complexity:  For every call to `match`, we will create those strings as described above, possibly creating duplicates.  If memory is not freed, this will also take a total of $$O\\big((T+P)2^{T + \\frac{P}{2}}\\big)$$ space, even though there are only order $$O(T^2 + P^2)$$ unique suffixes of $$P$$ and  $$T$$ that are actually required.\n<br />\n<br />\n\n---\n\n### Approach 2: Dynamic Programming\n\n**Intuition**\n\nAs the problem has an **optimal substructure**, it is natural to cache intermediate results.  We ask the question $$\\text{dp(i, j)}$$: does $$\\text{text[i:]}$$ and $$\\text{pattern[j:]}$$ match?  We can describe our answer in terms of answers to questions involving smaller strings.\n\n**Algorithm**\n\nWe proceed with the same recursion as in [Approach 1](#approach-1-recursion), except because calls will only ever be made to `match(text[i:], pattern[j:])`, we use $$\\text{dp(i, j)}$$ to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results.\n\n\n*Top-Down Variation*\n<iframe src=\"https://leetcode.com/playground/cXs5KPLc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"cXs5KPLc\"></iframe>\n\n*Bottom-Up Variation*\n\n<iframe src=\"https://leetcode.com/playground/GnSNNEQb/shared\" frameBorder=\"0\" width=\"100%\" height=\"412\" name=\"GnSNNEQb\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: Let $$T, P$$ be the lengths of the text and the pattern respectively.  The work for every call to `dp(i, j)` for $$i=0, ... ,T$$; $$j=0, ... ,P$$ is done once, and it is $$O(1)$$ work.  Hence, the time complexity is $$O(TP)$$.\n\n* Space Complexity:  The only memory we use is the $$O(TP)$$ boolean entries in our cache.  Hence, the space complexity is $$O(TP)$$."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/regular-expression-matching/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "11",
        "questionFrontendId": "11",
        "title": "Container With Most Water",
        "content": "<p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i<sup>th</sup></code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p>\n\n<p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p>\n\n<p>Return <em>the maximum amount of water a container can store</em>.</p>\n\n<p><strong>Notice</strong> that you may not slant the container.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg\" style=\"width: 600px; height: 287px;\" />\n<pre>\n<strong>Input:</strong> height = [1,8,6,2,5,4,8,3,7]\n<strong>Output:</strong> 49\n<strong>Explanation:</strong> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> height = [1,1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 33453,
        "dislikes": 2150,
        "stats": "{\"totalAccepted\": \"4.9M\", \"totalSubmission\": \"8.3M\", \"totalAcceptedRaw\": 4942965, \"totalSubmissionRaw\": 8339940, \"acRate\": \"59.3%\"}",
        "similarQuestions": "[{\"title\": \"Trapping Rain Water\", \"titleSlug\": \"trapping-rain-water\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Tastiness of Candy Basket\", \"titleSlug\": \"maximum-tastiness-of-candy-basket\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"House Robber IV\", \"titleSlug\": \"house-robber-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "If you simulate the problem, it will be O(n^2) which is not efficient.",
          "Try to use two-pointers. Set one pointer to the left and one to the right of the array. Always move the pointer that points to the lower line.",
          "How can you calculate the amount of water at each step?"
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Greedy"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/container-with-most-water/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "12",
        "questionFrontendId": "12",
        "title": "Integer to Roman",
        "content": "<p>Seven different symbols represent Roman numerals with the following values:</p>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Symbol</th>\n\t\t\t<th>Value</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>I</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>V</td>\n\t\t\t<td>5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>X</td>\n\t\t\t<td>10</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>L</td>\n\t\t\t<td>50</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>C</td>\n\t\t\t<td>100</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>D</td>\n\t\t\t<td>500</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>M</td>\n\t\t\t<td>1000</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>Roman numerals are formed by appending&nbsp;the conversions of&nbsp;decimal place values&nbsp;from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:</p>\n\n<ul>\n\t<li>If the value does not start with 4 or&nbsp;9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.</li>\n\t<li>If the value starts with 4 or 9 use the&nbsp;<strong>subtractive form</strong>&nbsp;representing&nbsp;one symbol subtracted from the following symbol, for example,&nbsp;4 is 1 (<code>I</code>) less than 5 (<code>V</code>): <code>IV</code>&nbsp;and 9 is 1 (<code>I</code>) less than 10 (<code>X</code>): <code>IX</code>.&nbsp;Only the following subtractive forms are used: 4 (<code>IV</code>), 9 (<code>IX</code>),&nbsp;40 (<code>XL</code>), 90 (<code>XC</code>), 400 (<code>CD</code>) and 900 (<code>CM</code>).</li>\n\t<li>Only powers of 10 (<code>I</code>, <code>X</code>, <code>C</code>, <code>M</code>) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5&nbsp;(<code>V</code>), 50 (<code>L</code>), or 500 (<code>D</code>) multiple times. If you need to append a symbol&nbsp;4 times&nbsp;use the <strong>subtractive form</strong>.</li>\n</ul>\n\n<p>Given an integer, convert it to a Roman numeral.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">num = 3749</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;MMMDCCXLIX&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">num = 58</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;LVIII&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\n50 = L\n 8 = VIII\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">num = 1994</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;MCMXCIV&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n</pre>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 3999</code></li>\n</ul>\n",
        "likes": 8382,
        "dislikes": 5709,
        "stats": "{\"totalAccepted\": \"2M\", \"totalSubmission\": \"2.9M\", \"totalAcceptedRaw\": 2002538, \"totalSubmissionRaw\": 2854261, \"acRate\": \"70.2%\"}",
        "similarQuestions": "[{\"title\": \"Roman to Integer\", \"titleSlug\": \"roman-to-integer\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Integer to English Words\", \"titleSlug\": \"integer-to-english-words\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Math"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/integer-to-roman/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "13",
        "questionFrontendId": "13",
        "title": "Roman to Integer",
        "content": "<p>Roman numerals are represented by seven different symbols:&nbsp;<code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n\n<pre>\n<strong>Symbol</strong>       <strong>Value</strong>\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</pre>\n\n<p>For example,&nbsp;<code>2</code> is written as <code>II</code>&nbsp;in Roman numeral, just two ones added together. <code>12</code> is written as&nbsp;<code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p>\n\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>\n\n<ul>\n\t<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.&nbsp;</li>\n\t<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.&nbsp;</li>\n\t<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>\n</ul>\n\n<p>Given a roman numeral, convert it to an integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;III&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> III = 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;LVIII&quot;\n<strong>Output:</strong> 58\n<strong>Explanation:</strong> L = 50, V= 5, III = 3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;MCMXCIV&quot;\n<strong>Output:</strong> 1994\n<strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 15</code></li>\n\t<li><code>s</code> contains only&nbsp;the characters <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code>.</li>\n\t<li>It is <strong>guaranteed</strong>&nbsp;that <code>s</code> is a valid roman numeral in the range <code>[1, 3999]</code>.</li>\n</ul>\n",
        "likes": 17256,
        "dislikes": 1197,
        "stats": "{\"totalAccepted\": \"5.5M\", \"totalSubmission\": \"8.4M\", \"totalAcceptedRaw\": 5543605, \"totalSubmissionRaw\": 8395130, \"acRate\": \"66.0%\"}",
        "similarQuestions": "[{\"title\": \"Integer to Roman\", \"titleSlug\": \"integer-to-roman\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Problem is simpler to solve by working the string from back to front and using a map."
        ],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "Math"
          },
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/roman-to-integer/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "14",
        "questionFrontendId": "14",
        "title": "Longest Common Prefix",
        "content": "<p>Write a function to find the longest common prefix string amongst an array of strings.</p>\n\n<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\n<strong>Output:</strong> &quot;fl&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> There is no common prefix among the input strings.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>\n\t<li><code>strs[i]</code> consists of only lowercase English letters if it is non-empty.</li>\n</ul>\n",
        "likes": 20769,
        "dislikes": 4878,
        "stats": "{\"totalAccepted\": \"5.4M\", \"totalSubmission\": \"11.5M\", \"totalAcceptedRaw\": 5366692, \"totalSubmissionRaw\": 11460016, \"acRate\": \"46.8%\"}",
        "similarQuestions": "[{\"title\": \"Smallest Missing Integer Greater Than Sequential Prefix Sum\", \"titleSlug\": \"smallest-missing-integer-greater-than-sequential-prefix-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Length of the Longest Common Prefix\", \"titleSlug\": \"find-the-length-of-the-longest-common-prefix\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Common Suffix Queries\", \"titleSlug\": \"longest-common-suffix-queries\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Common Prefix After at Most One Removal\", \"titleSlug\": \"longest-common-prefix-after-at-most-one-removal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          },
          {
            "name": "Trie"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n\n### Approach 1: Horizontal scanning\n\n#### Intuition\n\nFor a start we will describe a simple way of finding the longest prefix shared by a set of strings $$LCP(S_1  \\ldots  S_n)$$.\nWe will use the observation that :\n\n$$LCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n)$$\n\n#### Algorithm\n\n To employ this idea, the algorithm iterates through the strings $$[S_1  \\ldots  S_n]$$, finding at each iteration $$i$$ the longest common prefix of strings $$LCP(S_1  \\ldots  S_i)$$ When $$LCP(S_1  \\ldots  S_i)$$ is an empty string, the algorithm ends. Otherwise after $$n$$ iterations, the algorithm returns $$LCP(S_1  \\ldots  S_n)$$.\n\n ![Finding the longest common prefix](https://leetcode.com/media/original_images/14_basic.png){:width=\"539px\"}\n \n\n *Figure 1. Finding the longest common prefix (Horizontal scanning)*\n \n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/Eyfryo9Z/shared\" frameBorder=\"0\" width=\"100%\" height=\"310\" name=\"Eyfryo9Z\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.\n\n    In the worst case all $$n$$ strings are the same. The algorithm compares the string $$S1$$ with the other strings $$[S_2 \\ldots S_n]$$ There are $$S$$ character comparisons, where $$S$$ is the sum of all characters in the input array.\n\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Approach 2: Vertical scanning\n\n#### Algorithm\n\nImagine a very short string is the common prefix at the end of the array. The above approach will still do $$S$$ comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of  the strings) before moving on to the next column.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/WSSYVp4m/shared\" frameBorder=\"0\" width=\"100%\" height=\"310\" name=\"WSSYVp4m\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.\nIn the worst case there will be $$n$$ equal strings with length $$m$$ and the algorithm performs  $$S = m \\cdot n$$ character comparisons.\nEven though the worst case is still the same as [Approach 1](#approach-1-horizontal-scanning), in the best case there are at most $$n \\cdot minLen$$ comparisons where $$minLen$$ is the length of the shortest string in the array.\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Approach 3: Divide and conquer\n\n#### Intuition\n\nThe idea of the algorithm comes from the associative property of LCP operation. We notice that :\n$$LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))$$\n, where $$LCP(S_1 \\ldots S_n)$$ is the longest common prefix in set of strings $$[S_1 \\ldots S_n]$$ , $$1 < k < n$$\n\n#### Algorithm\n\nTo apply the observation above, we use divide and conquer technique, where we split the $$LCP(S_i \\ldots S_j)$$ problem into two subproblems $$LCP(S_i \\ldots S_{mid})$$   and $$LCP(S_{mid+1} \\ldots S_j)$$, where `mid` is $$\\frac{i + j}{2}$$. We use their solutions `lcpLeft` and `lcpRight` to construct the solution of the main problem $$LCP(S_i \\ldots S_j)$$. To accomplish this we compare one by one the characters of `lcpLeft` and `lcpRight` till there is no character match. The found common prefix of `lcpLeft` and `lcpRight` is the solution of the  $$LCP(S_i \\ldots S_j)$$.\n\n![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_diviso_et_lmpera.png){:width=\"539px\"}\n\n\n*Figure 2. Finding the longest common prefix of strings using divide and conquer technique*\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/DR56kG9E/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"DR56kG9E\"></iframe>\n\n#### Complexity Analysis\n\nIn the worst case we have $$n$$ equal strings with length $$m$$\n\n* Time complexity : $$O(S)$$, where $$S$$ is the number of all characters in the array, $$S = m \\cdot n$$\n Time complexity is $$2 \\cdot T\\left ( \\frac{n}{2} \\right ) + O(m)$$. Therefore time complexity is $$O(S)$$.\n  In the best case this algorithm performs  $$O(minLen \\cdot n)$$ comparisons, where  $$minLen$$ is the shortest string of the array\n\n* Space complexity : $$O(m \\cdot \\log n)$$\n\n    There is a memory overhead since we store recursive calls in the execution stack. There are $$\\log n$$ recursive calls, each store need $$m$$ space to store the result,  so space complexity is $$O(m \\cdot \\log n)$$\n\n\n---\n\n### Approach 4: Binary search\n\n#### Intuition\n\nThe idea is to apply binary search method to find the string with maximum value `L`, which is common prefix of all of the strings. The algorithm searches space is the interval $$(0 \\ldots minLen)$$, where `minLen` is minimum string length and the maximum possible common prefix. Each time search space is divided in two equal parts, one of them is discarded, because it is sure that it doesn't contain the solution. There are two possible cases:\n* `S[1...mid]` is not a common string. This means that for each `j > i S[1..j]` is not a common string and we discard the second half of the  search space.\n* `S[1...mid]` is common string. This means that for each `i < j S[1..i]` is a common string and we discard the first half of the search space, because we try to find longer common prefix.\n\n![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_binary_search.png){:width=\"539px\"}\n\n\n*Figure 3. Finding the longest common prefix of strings using binary search technique*\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/M2tJuDXZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"M2tJuDXZ\"></iframe>\n\n#### Complexity Analysis\n\nIn the worst case we have $$n$$ equal strings with length $$m$$\n\n* Time complexity : $$O(S \\cdot \\log m)$$, where $$S$$ is the sum of all characters in all strings.\n\n    The algorithm makes $$\\log m$$ iterations, for each of them there are $$S = m \\cdot n$$ comparisons, which gives in total $$O(S \\cdot \\log m)$$ time complexity.\n\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Further Thoughts / Follow up\n\nLet's take a look at a slightly different problem:\n\n> Given a set of keys S = $$[S_1,S_2 \\ldots S_n]$$, find the longest common prefix among a string `q` and S. This LCP query will be called frequently.\n\nWe could optimize LCP queries by storing the set of keys S in a Trie. For more information about Trie, please see this article [Implement a trie (Prefix trie)](https://leetcode.com/articles/implement-trie-prefix-tree/). In a Trie, each node descending from the root represents a common prefix of some keys. But we need to find the longest common prefix of a string `q` and all key strings. This means that we have to find the deepest path from the root, which satisfies the following conditions:\n* it is prefix of query string `q`\n* each node along the path must contain only one child element. Otherwise the found path will not be a common prefix among all strings.\n* the path doesn't comprise of nodes which are marked as end of key. Otherwise the path couldn't be a prefix a of key which is shorter than itself.\n\n#### Algorithm\n\nThe only question left, is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from $$[S_1 \\ldots   S_n]$$ strings. Then find the prefix of query string `q` in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied.\n\n![Finding the longest common prefix using Trie](../Figures/14/14_lcp_trie_fix.png)\n\n*Figure 4. Finding the longest common prefix of strings using Trie*\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/bcDyZ5WU/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"bcDyZ5WU\"></iframe>\n\n#### Complexity Analysis\n\nIn the worst case query $$q$$ has length $$m$$ and it is equal to all $$n$$ strings of the array.\n\n* Time complexity : preprocessing $$O(S)$$, where $$S$$ is the number of all characters in the array, LCP query $$O(m)$$.\n\n    Trie build has $$O(S)$$ time complexity. To find the common prefix of $$q$$ in the Trie takes in the worst case $$O(m)$$.\n\n* Space complexity : $$O(S)$$. We only used additional  $$S$$ extra space for the Trie."
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/longest-common-prefix/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "15",
        "questionFrontendId": "15",
        "title": "3Sum",
        "content": "<p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>\n\n<p>Notice that the solution set must not contain duplicate triplets.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,1,2,-1,-4]\n<strong>Output:</strong> [[-1,-1,2],[-1,0,1]]\n<strong>Explanation:</strong> \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,1]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The only possible triplet does not sum up to 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,0]\n<strong>Output:</strong> [[0,0,0]]\n<strong>Explanation:</strong> The only possible triplet sums up to 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 34843,
        "dislikes": 3236,
        "stats": "{\"totalAccepted\": \"5.5M\", \"totalSubmission\": \"14.4M\", \"totalAcceptedRaw\": 5531760, \"totalSubmissionRaw\": 14434764, \"acRate\": \"38.3%\"}",
        "similarQuestions": "[{\"title\": \"Two Sum\", \"titleSlug\": \"two-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"3Sum Closest\", \"titleSlug\": \"3sum-closest\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"4Sum\", \"titleSlug\": \"4sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"3Sum Smaller\", \"titleSlug\": \"3sum-smaller\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Arithmetic Triplets\", \"titleSlug\": \"number-of-arithmetic-triplets\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Sum of Mountain Triplets I\", \"titleSlug\": \"minimum-sum-of-mountain-triplets-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Sum of Mountain Triplets II\", \"titleSlug\": \"minimum-sum-of-mountain-triplets-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "So, we essentially need to find three numbers x, y, and z such that they add up to the given value. If we fix one of the numbers say x, we are left with the two-sum problem at hand!",
          "For the two-sum problem, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y, which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
          "The second train of thought for two-sum is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/3sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "16",
        "questionFrontendId": "16",
        "title": "3Sum Closest",
        "content": "<p>Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers at <strong>distinct indices</strong> in <code>nums</code> such that the sum is closest to <code>target</code>.</p>\n\n<p>Return <em>the sum of the three integers</em>.</p>\n\n<p>You may assume that each input would have exactly one solution.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,2,1,-4], target = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,0], target = 1\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 11457,
        "dislikes": 615,
        "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"3.6M\", \"totalAcceptedRaw\": 1710298, \"totalSubmissionRaw\": 3576792, \"acRate\": \"47.8%\"}",
        "similarQuestions": "[{\"title\": \"3Sum\", \"titleSlug\": \"3sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"3Sum Smaller\", \"titleSlug\": \"3sum-smaller\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/3sum-closest/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "17",
        "questionFrontendId": "17",
        "title": "Letter Combinations of a Phone Number",
        "content": "<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p>\n\n<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png\" style=\"width: 300px; height: 243px;\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;23&quot;\n<strong>Output:</strong> [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;2&quot;\n<strong>Output:</strong> [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 4</code></li>\n\t<li><code>digits[i]</code> is a digit in the range <code>[&#39;2&#39;, &#39;9&#39;]</code>.</li>\n</ul>\n",
        "likes": 20633,
        "dislikes": 1118,
        "stats": "{\"totalAccepted\": \"2.9M\", \"totalSubmission\": \"4.4M\", \"totalAcceptedRaw\": 2861069, \"totalSubmissionRaw\": 4386360, \"acRate\": \"65.2%\"}",
        "similarQuestions": "[{\"title\": \"Generate Parentheses\", \"titleSlug\": \"generate-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Combination Sum\", \"titleSlug\": \"combination-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Watch\", \"titleSlug\": \"binary-watch\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Number of Texts\", \"titleSlug\": \"count-number-of-texts\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Pushes to Type Word I\", \"titleSlug\": \"minimum-number-of-pushes-to-type-word-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Pushes to Type Word II\", \"titleSlug\": \"minimum-number-of-pushes-to-type-word-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "18",
        "questionFrontendId": "18",
        "title": "4Sum",
        "content": "<p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c, d&nbsp;&lt; n</code></li>\n\t<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>\n\t<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>\n</ul>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,-1,0,-2,2], target = 0\n<strong>Output:</strong> [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2], target = 8\n<strong>Output:</strong> [[2,2,2,2]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 12663,
        "dislikes": 1525,
        "stats": "{\"totalAccepted\": \"1.6M\", \"totalSubmission\": \"3.9M\", \"totalAcceptedRaw\": 1550338, \"totalSubmissionRaw\": 3906754, \"acRate\": \"39.7%\"}",
        "similarQuestions": "[{\"title\": \"Two Sum\", \"titleSlug\": \"two-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"3Sum\", \"titleSlug\": \"3sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"4Sum II\", \"titleSlug\": \"4sum-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Special Quadruplets\", \"titleSlug\": \"count-special-quadruplets\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\nThis problem is a follow-up of [3Sum](https://leetcode.com/articles/3sum/), so take a look at that problem first if you haven't. 4Sum and 3Sum are very similar; the difference is that we are looking for unique quadruplets instead of triplets.\n\nAs you see, 3Sum just wraps Two Sum in an outer loop. As it iterates through each value `v`, it finds all pairs whose sum is equal to `target - v` using one of these approaches:\n\n1. [Two Sum](https://leetcode.com/articles/two-sum/) uses a hash set to check for a matching value.\n2. [Two Sum II](https://leetcode.com/articles/two-sum-ii-input-array-is-sorted/) uses the two pointers pattern in a sorted array.\n\nFollowing a similar logic, we can implement 4Sum by wrapping 3Sum in another loop. But wait - there is a catch. If an interviewer asks you to solve 4Sum, they can follow-up with 5Sum, 6Sum, and so on. What they are really expecting at this point is a kSum solution. Therefore, we will focus on a generalized implementation here.\n\n---\n\n### Approach 1: Two Pointers\n\n**Intuition**\n\nThe two pointers pattern requires the array to be sorted, so we do that first.  Also, it's easier to deal with duplicates if the array is sorted: repeated values are next to each other and easy to skip.\n\nFor 3Sum, we enumerate each value in a single loop, and use the two pointers pattern for the rest of the array. For kSum, we will have `k - 2` nested loops to enumerate all combinations of `k - 2` values.\n\n!?!../Documents/18_4Sum.json:1200,440!?!\n\n**Algorithm**\n\nWe can implement `k - 2` loops using a recursion. We will pass the starting point and `k` as the parameters. When `k == 2`, we will call `twoSum`, terminating the recursion.\n\n1. For the main function:\n    - Sort the input array `nums`.\n    - Call `kSum` with `start = 0`, `k = 4`, and `target`, and return the result.\n\n2. For `kSum` function:\n    - At the start of the `kSum` function, we will check three conditions:\n      1. Have we run out of numbers to choose from?\n      2. Is the smallest number remaining greater than `target / k`? <br>If so, then any `k` numbers we choose will be too large.\n      3. Is the largest number remaining smaller than `target / k`? <br>If so, then any `k` numbers we choose will be too small.\n      - If any of these conditions is true, there is no need to continue as no combination of the remaining elements can sum to `target`.\n    - If `k` equals `2`, call `twoSum` and return the result.\n    - Iterate `i` through the array from `start`:\n        - If the current value is the same as the one before, skip it.\n        - Recursively call `kSum` with `start = i + 1`, `k = k - 1`, and `target - nums[i]`.\n        - For each returned `subset` of values:\n            - Include the current value `nums[i]` into `subset`.\n            - Add `subset` to the result `res`.\n    - Return the result `res`.\n\n3. For `twoSum` function:\n    - Set the low pointer `lo` to `start`, and high pointer `hi` to the last index.\n    - While low pointer is smaller than high:\n        - If the sum of `nums[lo]` and `nums[hi]` is less than `target`, increment `lo`.\n            - Also increment `lo` if the value is the same as for `lo - 1`.\n        - If the sum is greater than `target`, decrement `hi`.\n            - Also decrement `hi` if the value is the same as for `hi + 1`.\n        - Otherwise, we found a pair:\n            - Add it to the result `res`.\n            - Decrement `hi` and increment `lo`.\n    - Return the result `res`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/mQdTCUXD/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"mQdTCUXD\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity: $$O(n^{k - 1})$$, or $$O(n^3)$$ for 4Sum. We have $$k - 2$$ loops, and `twoSum` is $$O(n)$$.\n\n    Note that for $$k > 2$$, sorting the array does not change the overall time complexity.\n\n- Space Complexity: $$O(n)$$. We need $$O(k)$$ space for the recursion. $$k$$ can be the same as $$n$$ in the worst case for the generalized algorithm.\n\n    Note that, for the purpose of complexity analysis, we ignore the memory required for the output.\n\n---\n\n### Approach 2: Hash Set\n    \n**Intuition**\n\nSince elements must sum up to the exact target value, we can also use the [Two Sum: One-pass Hash Table](https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table) approach.\n\nIn [3Sum: Hash Set](https://leetcode.com/articles/3sum/#approach-2-hash-set), we solved the problem without sorting the array. To do that, we needed to sort values within triplets, and track them in a hash set. Doing the same for k values could be impractical.\n\nSo, for this approach, we will also sort the array and skip duplicates the same way as in the Two Pointers approach above. Thus, the code will only differ in the `twoSum` implementation.\n\n**Algorithm**\n\n`twoSum` implementation here is almost the same as in [Two Sum: One-pass Hash Table](https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table). The only difference is the check to avoid duplicates. Since the array is sorted, we can just compare the found pair with the last one in the result `res`.\n    \n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/oAq3g56d/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"oAq3g56d\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity: $$O(n^{k - 1})$$, or $$O(n^3)$$ for 4Sum. We have $$k - 2$$ loops iterating over $$n$$ elements, and `twoSum` is $$O(n)$$.\n\n    Note that for $$k > 2$$, sorting the array does not change the overall time complexity.\n\n- Space Complexity: $$O(n)$$ for the hash set. The space needed for the recursion will not exceed $$O(n)$$."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/4sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "19",
        "questionFrontendId": "19",
        "title": "Remove Nth Node From End of List",
        "content": "<p>Given the <code>head</code> of a linked list, remove the <code>n<sup>th</sup></code> node from the end of the list and return its head.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], n = 2\n<strong>Output:</strong> [1,2,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1], n = 1\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,2], n = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>sz</code>.</li>\n\t<li><code>1 &lt;= sz &lt;= 30</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do this in one pass?</p>\n",
        "likes": 20939,
        "dislikes": 886,
        "stats": "{\"totalAccepted\": \"4M\", \"totalSubmission\": \"7.8M\", \"totalAcceptedRaw\": 3968195, \"totalSubmissionRaw\": 7830014, \"acRate\": \"50.7%\"}",
        "similarQuestions": "[{\"title\": \"Swapping Nodes in a Linked List\", \"titleSlug\": \"swapping-nodes-in-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Delete N Nodes After M Nodes of a Linked List\", \"titleSlug\": \"delete-n-nodes-after-m-nodes-of-a-linked-list\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Delete the Middle Node of a Linked List\", \"titleSlug\": \"delete-the-middle-node-of-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Maintain two pointers and update one with a delay of n steps."
        ],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "20",
        "questionFrontendId": "20",
        "title": "Valid Parentheses",
        "content": "<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\n\n<p>An input string is valid if:</p>\n\n<ol>\n\t<li>Open brackets must be closed by the same type of brackets.</li>\n\t<li>Open brackets must be closed in the correct order.</li>\n\t<li>Every close bracket has a corresponding open bracket of the same type.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;()&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;()[]{}&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;(]&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;([])&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p><strong class=\"example\">Example 5:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;([)]&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code>.</li>\n</ul>\n",
        "likes": 27291,
        "dislikes": 1976,
        "stats": "{\"totalAccepted\": \"7.1M\", \"totalSubmission\": \"16.2M\", \"totalAcceptedRaw\": 7060483, \"totalSubmissionRaw\": 16241765, \"acRate\": \"43.5%\"}",
        "similarQuestions": "[{\"title\": \"Generate Parentheses\", \"titleSlug\": \"generate-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Valid Parentheses\", \"titleSlug\": \"longest-valid-parentheses\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Remove Invalid Parentheses\", \"titleSlug\": \"remove-invalid-parentheses\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Check If Word Is Valid After Substitutions\", \"titleSlug\": \"check-if-word-is-valid-after-substitutions\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Check if a Parentheses String Can Be Valid\", \"titleSlug\": \"check-if-a-parentheses-string-can-be-valid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Move Pieces to Obtain a String\", \"titleSlug\": \"move-pieces-to-obtain-a-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Use a stack of characters.",
          "When you encounter an opening bracket, push it to the top of the stack.",
          "When you encounter a closing bracket, check if the top of the stack was the opening for it. If yes, pop it from the stack. Otherwise, return false."
        ],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/valid-parentheses/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "21",
        "questionFrontendId": "21",
        "title": "Merge Two Sorted Lists",
        "content": "<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p>\n\n<p>Merge the two lists into one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>\n\n<p>Return <em>the head of the merged linked list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\" style=\"width: 662px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> list1 = [1,2,4], list2 = [1,3,4]\n<strong>Output:</strong> [1,1,2,3,4,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [], list2 = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [], list2 = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n",
        "likes": 24543,
        "dislikes": 2411,
        "stats": "{\"totalAccepted\": \"5.9M\", \"totalSubmission\": \"8.7M\", \"totalAcceptedRaw\": 5925913, \"totalSubmissionRaw\": 8747713, \"acRate\": \"67.7%\"}",
        "similarQuestions": "[{\"title\": \"Merge k Sorted Lists\", \"titleSlug\": \"merge-k-sorted-lists\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Merge Sorted Array\", \"titleSlug\": \"merge-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sort List\", \"titleSlug\": \"sort-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Shortest Word Distance II\", \"titleSlug\": \"shortest-word-distance-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add Two Polynomials Represented as Linked Lists\", \"titleSlug\": \"add-two-polynomials-represented-as-linked-lists\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Common Subsequence Between Sorted Arrays\", \"titleSlug\": \"longest-common-subsequence-between-sorted-arrays\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Merge Two 2D Arrays by Summing Values\", \"titleSlug\": \"merge-two-2d-arrays-by-summing-values\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/merge-two-sorted-lists/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "22",
        "questionFrontendId": "22",
        "title": "Generate Parentheses",
        "content": "<p>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 3\n<strong>Output:</strong> [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> [\"()\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "likes": 22997,
        "dislikes": 1067,
        "stats": "{\"totalAccepted\": \"2.7M\", \"totalSubmission\": \"3.5M\", \"totalAcceptedRaw\": 2713708, \"totalSubmissionRaw\": 3475261, \"acRate\": \"78.1%\"}",
        "similarQuestions": "[{\"title\": \"Letter Combinations of a Phone Number\", \"titleSlug\": \"letter-combinations-of-a-phone-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Valid Parentheses\", \"titleSlug\": \"valid-parentheses\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Check if a Parentheses String Can Be Valid\", \"titleSlug\": \"check-if-a-parentheses-string-can-be-valid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/generate-parentheses/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "23",
        "questionFrontendId": "23",
        "title": "Merge k Sorted Lists",
        "content": "<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>\n\n<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>Output:</strong> [1,1,2,3,4,4,5,6]\n<strong>Explanation:</strong> The linked-lists are:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\nmerging them into one sorted linked list:\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = [[]]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= lists[i][j] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li>\n\t<li>The sum of <code>lists[i].length</code> will not exceed <code>10<sup>4</sup></code>.</li>\n</ul>\n",
        "likes": 21053,
        "dislikes": 783,
        "stats": "{\"totalAccepted\": \"2.8M\", \"totalSubmission\": \"4.8M\", \"totalAcceptedRaw\": 2821819, \"totalSubmissionRaw\": 4820074, \"acRate\": \"58.5%\"}",
        "similarQuestions": "[{\"title\": \"Merge Two Sorted Lists\", \"titleSlug\": \"merge-two-sorted-lists\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Ugly Number II\", \"titleSlug\": \"ugly-number-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest Subarrays With Maximum Bitwise OR\", \"titleSlug\": \"smallest-subarrays-with-maximum-bitwise-or\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Heap (Priority Queue)"
          },
          {
            "name": "Merge Sort"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/merge-k-sorted-lists/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "24",
        "questionFrontendId": "24",
        "title": "Swap Nodes in Pairs",
        "content": "<p>Given a&nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&nbsp;modifying the values in the list&#39;s nodes (i.e., only nodes themselves may be changed.)</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">head = [1,2,3,4]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[2,1,4,3]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\" style=\"width: 422px; height: 222px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">head = []</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">head = [1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">head = [1,2,3]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[2,1,3]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the&nbsp;list&nbsp;is in the range <code>[0, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "likes": 12969,
        "dislikes": 504,
        "stats": "{\"totalAccepted\": \"1.8M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 1822123, \"totalSubmissionRaw\": 2653573, \"acRate\": \"68.7%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Nodes in k-Group\", \"titleSlug\": \"reverse-nodes-in-k-group\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Swapping Nodes in a Linked List\", \"titleSlug\": \"swapping-nodes-in-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/swap-nodes-in-pairs/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "25",
        "questionFrontendId": "25",
        "title": "Reverse Nodes in k-Group",
        "content": "<p>Given the <code>head</code> of a linked list, reverse the nodes of the list <code>k</code> at a time, and return <em>the modified list</em>.</p>\n\n<p><code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes, in the end, should remain as it is.</p>\n\n<p>You may not alter the values in the list&#39;s nodes, only nodes themselves may be changed.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], k = 2\n<strong>Output:</strong> [2,1,4,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], k = 3\n<strong>Output:</strong> [3,2,1,4,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>n</code>.</li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you solve the problem in <code>O(1)</code> extra memory space?</p>\n",
        "likes": 15411,
        "dislikes": 795,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"2.2M\", \"totalAcceptedRaw\": 1433213, \"totalSubmissionRaw\": 2205832, \"acRate\": \"65.0%\"}",
        "similarQuestions": "[{\"title\": \"Swap Nodes in Pairs\", \"titleSlug\": \"swap-nodes-in-pairs\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Swapping Nodes in a Linked List\", \"titleSlug\": \"swapping-nodes-in-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Reverse Nodes in Even Length Groups\", \"titleSlug\": \"reverse-nodes-in-even-length-groups\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "26",
        "questionFrontendId": "26",
        "title": "Remove Duplicates from Sorted Array",
        "content": "<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p>\n\n<p>Consider the number of <em>unique elements</em> in&nbsp;<code>nums</code> to be <code>k<strong>\u200b\u200b\u200b\u200b\u200b\u200b\u200b</strong></code>\u200b\u200b\u200b\u200b\u200b\u200b\u200b. <meta charset=\"UTF-8\" />After removing duplicates, return the number of unique elements&nbsp;<code>k</code>.</p>\n\n<p><meta charset=\"UTF-8\" />The first&nbsp;<code>k</code>&nbsp;elements of&nbsp;<code>nums</code>&nbsp;should contain the unique numbers in <strong>sorted order</strong>. The remaining elements beyond index&nbsp;<code>k - 1</code>&nbsp;can be ignored.</p>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The judge will test your solution with the following code:</p>\n\n<pre>\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</pre>\n\n<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,2]\n<strong>Output:</strong> 2, nums = [1,2,_]\n<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,1,1,1,2,2,3,3,4]\n<strong>Output:</strong> 5, nums = [0,1,2,3,4,_,_,_,_,_]\n<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n",
        "likes": 18419,
        "dislikes": 20378,
        "stats": "{\"totalAccepted\": \"7.3M\", \"totalSubmission\": \"11.8M\", \"totalAcceptedRaw\": 7312634, \"totalSubmissionRaw\": 11806267, \"acRate\": \"61.9%\"}",
        "similarQuestions": "[{\"title\": \"Remove Element\", \"titleSlug\": \"remove-element\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Remove Duplicates from Sorted Array II\", \"titleSlug\": \"remove-duplicates-from-sorted-array-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Apply Operations to an Array\", \"titleSlug\": \"apply-operations-to-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sum of Distances\", \"titleSlug\": \"sum-of-distances\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "In this problem, the key point to focus on is the input array being sorted. As far as duplicate elements are concerned, what is their positioning in the array when the given array is sorted? Look at the image below for the answer. If we know the position of one of the elements, do we also know the positioning of all the duplicate elements?\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_rem_dup.png\" width=\"500\"/>",
          "We need to modify the array in-place and the size of the final array would potentially be smaller than the size of the input array. So, we ought to use a two-pointer approach here. One, that would keep track of the current element in the original array and another one for just the unique elements.",
          "Essentially, once an element is encountered, you simply need to <b>bypass</b> its duplicates and move on to the next unique element."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "27",
        "questionFrontendId": "27",
        "title": "Remove Element",
        "content": "<p>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a>. The order of the elements may be changed. Then return <em>the number of elements in </em><code>nums</code><em> which are not equal to </em><code>val</code>.</p>\n\n<p>Consider the number of elements in <code>nums</code> which are not equal to <code>val</code> be <code>k</code>, to get accepted, you need to do the following things:</p>\n\n<ul>\n\t<li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the elements which are not equal to <code>val</code>. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li>\n\t<li>Return <code>k</code>.</li>\n</ul>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The judge will test your solution with the following code:</p>\n\n<pre>\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i &lt; actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</pre>\n\n<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,2,3], val = 3\n<strong>Output:</strong> 2, nums = [2,2,_,_]\n<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,2,2,3,0,4,2], val = 2\n<strong>Output:</strong> 5, nums = [0,1,4,0,3,_,_,_]\n<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n\t<li><code>0 &lt;= val &lt;= 100</code></li>\n</ul>\n",
        "likes": 4782,
        "dislikes": 5226,
        "stats": "{\"totalAccepted\": \"4.9M\", \"totalSubmission\": \"8M\", \"totalAcceptedRaw\": 4894915, \"totalSubmissionRaw\": 8007789, \"acRate\": \"61.1%\"}",
        "similarQuestions": "[{\"title\": \"Remove Duplicates from Sorted Array\", \"titleSlug\": \"remove-duplicates-from-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Remove Linked List Elements\", \"titleSlug\": \"remove-linked-list-elements\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Move Zeroes\", \"titleSlug\": \"move-zeroes\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "The problem statement clearly asks us to modify the array in-place and it also says that the element beyond the new length of the array can be anything. Given an element, we need to remove all the occurrences of it from the array. We don't technically need to <b>remove</b> that element per se, right?",
          "We can move all the occurrences of this element to the end of the array. Use two pointers!\r\n<br><img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_remove_element.png\" width=\"500\"/>",
          "Yet another direction of thought is to consider the elements to be removed as non-existent. In a single pass, if we keep copying the visible elements in-place, that should also solve this problem for us."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/remove-element/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "28",
        "questionFrontendId": "28",
        "title": "Find the Index of the First Occurrence in a String",
        "content": "<p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> &quot;sad&quot; occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> &quot;leeto&quot; did not occur in &quot;leetcode&quot;, so we return -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= haystack.length, needle.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li>\n</ul>\n",
        "likes": 7378,
        "dislikes": 560,
        "stats": "{\"totalAccepted\": \"3.8M\", \"totalSubmission\": \"8.3M\", \"totalAcceptedRaw\": 3824854, \"totalSubmissionRaw\": 8304669, \"acRate\": \"46.1%\"}",
        "similarQuestions": "[{\"title\": \"Shortest Palindrome\", \"titleSlug\": \"shortest-palindrome\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Repeated Substring Pattern\", \"titleSlug\": \"repeated-substring-pattern\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Two Pointers"
          },
          {
            "name": "String"
          },
          {
            "name": "String Matching"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "29",
        "questionFrontendId": "29",
        "title": "Divide Two Integers",
        "content": "<p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers <strong>without</strong> using multiplication, division, and mod operator.</p>\n\n<p>The integer division should truncate toward zero, which means losing its fractional part. For example, <code>8.345</code> would be truncated to <code>8</code>, and <code>-2.7335</code> would be truncated to <code>-2</code>.</p>\n\n<p>Return <em>the <strong>quotient</strong> after dividing </em><code>dividend</code><em> by </em><code>divisor</code>.</p>\n\n<p><strong>Note: </strong>Assume we are dealing with an environment that could only store integers within the <strong>32-bit</strong> signed integer range: <code>[&minus;2<sup>31</sup>, 2<sup>31</sup> &minus; 1]</code>. For this problem, if the quotient is <strong>strictly greater than</strong> <code>2<sup>31</sup> - 1</code>, then return <code>2<sup>31</sup> - 1</code>, and if the quotient is <strong>strictly less than</strong> <code>-2<sup>31</sup></code>, then return <code>-2<sup>31</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> dividend = 10, divisor = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 10/3 = 3.33333.. which is truncated to 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> dividend = 7, divisor = -3\n<strong>Output:</strong> -2\n<strong>Explanation:</strong> 7/-3 = -2.33333.. which is truncated to -2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= dividend, divisor &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>divisor != 0</code></li>\n</ul>\n",
        "likes": 5993,
        "dislikes": 15245,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"5.7M\", \"totalAcceptedRaw\": 1089461, \"totalSubmissionRaw\": 5668569, \"acRate\": \"19.2%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/divide-two-integers/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "30",
        "questionFrontendId": "30",
        "title": "Substring with Concatenation of All Words",
        "content": "<p>You are given a string <code>s</code> and an array of strings <code>words</code>. All the strings of <code>words</code> are of <strong>the same length</strong>.</p>\n\n<p>A <strong>concatenated string</strong> is a string that exactly contains all the strings of any permutation of <code>words</code> concatenated.</p>\n\n<ul>\n\t<li>For example, if <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>, then <code>&quot;abcdef&quot;</code>, <code>&quot;abefcd&quot;</code>, <code>&quot;cdabef&quot;</code>, <code>&quot;cdefab&quot;</code>, <code>&quot;efabcd&quot;</code>, and <code>&quot;efcdab&quot;</code> are all concatenated strings. <code>&quot;acdbef&quot;</code> is not a concatenated string because it is not the concatenation of any permutation of <code>words</code>.</li>\n</ul>\n\n<p>Return an array of <em>the starting indices</em> of all the concatenated substrings in <code>s</code>. You can return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[0,9]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The substring starting at 0 is <code>&quot;barfoo&quot;</code>. It is the concatenation of <code>[&quot;bar&quot;,&quot;foo&quot;]</code> which is a permutation of <code>words</code>.<br />\nThe substring starting at 9 is <code>&quot;foobar&quot;</code>. It is the concatenation of <code>[&quot;foo&quot;,&quot;bar&quot;]</code> which is a permutation of <code>words</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>There is no concatenated substring.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[6,9,12]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The substring starting at 6 is <code>&quot;foobarthe&quot;</code>. It is the concatenation of <code>[&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;]</code>.<br />\nThe substring starting at 9 is <code>&quot;barthefoo&quot;</code>. It is the concatenation of <code>[&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;]</code>.<br />\nThe substring starting at 12 is <code>&quot;thefoobar&quot;</code>. It is the concatenation of <code>[&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;]</code>.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>s</code> and <code>words[i]</code> consist of lowercase English letters.</li>\n</ul>\n",
        "likes": 2542,
        "dislikes": 416,
        "stats": "{\"totalAccepted\": \"666.2K\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 666174, \"totalSubmissionRaw\": 1972333, \"acRate\": \"33.8%\"}",
        "similarQuestions": "[{\"title\": \"Minimum Window Substring\", \"titleSlug\": \"minimum-window-substring\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Sliding Window"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "31",
        "questionFrontendId": "31",
        "title": "Next Permutation",
        "content": "<p>A <strong>permutation</strong> of an array of integers is an arrangement of its members into a sequence or linear order.</p>\n\n<ul>\n\t<li>For example, for <code>arr = [1,2,3]</code>, the following are all the permutations of <code>arr</code>: <code>[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]</code>.</li>\n</ul>\n\n<p>The <strong>next permutation</strong> of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the <strong>next permutation</strong> of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).</p>\n\n<ul>\n\t<li>For example, the next permutation of <code>arr = [1,2,3]</code> is <code>[1,3,2]</code>.</li>\n\t<li>Similarly, the next permutation of <code>arr = [2,3,1]</code> is <code>[3,1,2]</code>.</li>\n\t<li>While the next permutation of <code>arr = [3,2,1]</code> is <code>[1,2,3]</code> because <code>[3,2,1]</code> does not have a lexicographical larger rearrangement.</li>\n</ul>\n\n<p>Given an array of integers <code>nums</code>, <em>find the next permutation of</em> <code>nums</code>.</p>\n\n<p>The replacement must be <strong><a href=\"http://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in place</a></strong> and use only constant extra memory.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [1,3,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,5]\n<strong>Output:</strong> [1,5,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "likes": 21004,
        "dislikes": 5077,
        "stats": "{\"totalAccepted\": \"2.1M\", \"totalSubmission\": \"4.8M\", \"totalAcceptedRaw\": 2127378, \"totalSubmissionRaw\": 4782832, \"acRate\": \"44.5%\"}",
        "similarQuestions": "[{\"title\": \"Permutations\", \"titleSlug\": \"permutations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutations II\", \"titleSlug\": \"permutations-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutation Sequence\", \"titleSlug\": \"permutation-sequence\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Palindrome Permutation II\", \"titleSlug\": \"palindrome-permutation-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Adjacent Swaps to Reach the Kth Smallest Number\", \"titleSlug\": \"minimum-adjacent-swaps-to-reach-the-kth-smallest-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Brute Force\n\n**Algorithm**\n\nIn this approach, we find out every possible permutation of list formed by the elements of the given array and find out the permutation which is\njust larger than the given one. But this one will be a very naive approach, since it requires us to find out every possible permutation\n which will take really long time and the implementation is complex.\n Thus, this approach is not acceptable at all. Hence, we move on directly to the correct approach.\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n!)$$. Total possible permutations is $$n!$$.\n* Space complexity : $$O(n)$$. Since an array will be used to store the permutations.\n<br />\n<br />\n\n---\n\n### Approach 2: Single Pass Approach\n\n**Algorithm**\n\nFirst, we observe that for any given sequence that is in descending order, no next larger permutation is possible.\n For example, no next permutation is possible for the following array:\n ```\n [9, 5, 4, 3, 1]\n ```\n\nWe need to find the first pair of two successive numbers $$a[i]$$ and $$a[i-1]$$, from the right, which satisfy\n $$a[i] > a[i-1]$$. Now, no rearrangements to the right of $$a[i-1]$$ can create a larger permutation since that subarray consists of numbers in descending order.\n Thus, we need to rearrange the numbers to the right of $$a[i-1]$$ including itself.\n\nNow, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number $$a[i-1]$$ with the number which is just larger than itself among the numbers lying to its right section, say $$a[j]$$.\n\n![ Next Permutation ](https://leetcode.com/media/original_images/31_nums_graph.png)\n\nWe swap the numbers $$a[i-1]$$ and $$a[j]$$. We now have the correct number at index $$i-1$$. But still the current permutation isn't the permutation\n    that we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of $$a[i-1]$$. Therefore, we need to place those\n     numbers in ascending order to get their smallest permutation.\n\nBut, recall that while scanning the numbers from the right, we simply kept decrementing the index\n      until we found the pair $$a[i]$$ and $$a[i-1]$$ where,  $$a[i] > a[i-1]$$. Thus, all numbers to the right of $$a[i-1]$$ were already sorted in descending order.\n      Furthermore, swapping $$a[i-1]$$ and $$a[j]$$ didn't change that order.\n      Therefore, we simply need to reverse the numbers following $$a[i-1]$$ to get the next smallest lexicographic permutation.\n\nThe following animation will make things clearer:\n\n![Next Permutation](https://leetcode.com/media/original_images/31_Next_Permutation.gif)\n\n<iframe src=\"https://leetcode.com/playground/Dm6PeACq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Dm6PeACq\"></iframe>\n\n**Complexity Analysis**\n\nLet $n$ be the size of the `nums` array.\n\n- Time complexity: $O(n)$\n\n   The first `while` loop runs at most $n$ iterations, decrementing the variable `i` as it searches for the first decreasing element from the right. In the worst case, it checks all elements, so it takes $O(n)$ time.\n    \n   The second `while` loop also runs at most $n$ iterations, decrementing the variable `j` as it searches for the smallest element larger than `nums[i]`. Similarly, it can take $O(n)$ time.\n    \n   The `reverse` function is called on a portion of the array, from index `i + 1` to the end. In the worst case, this can cover the entire array, leading to a time complexity of $O(n)$.\n    \n   The `swap` function runs in constant time, $O(1)$, since it only exchanges two elements.\n    \n    Therefore, the overall time complexity is $O(n)$.\n\n- Space complexity: $O(1)$\n\n   The function operates in-place on the `nums` array, meaning no extra space is used for storing additional data.\n    \n   Only a few constant space variables (`i`, `j`, and `temp`) are used.\n    \n   The built-in `swap` and `reverse` functions do not require additional space beyond what is already present in the input array.\n\n    Hence, the space complexity is $O(1)$."
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/next-permutation/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "32",
        "questionFrontendId": "32",
        "title": "Longest Valid Parentheses",
        "content": "<p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, return <em>the length of the longest valid (well-formed) parentheses </em><span data-keyword=\"substring-nonempty\"><em>substring</em></span>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(()&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The longest valid parentheses substring is &quot;()&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;)()())&quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest valid parentheses substring is &quot;()()&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> is <code>&#39;(&#39;</code>, or <code>&#39;)&#39;</code>.</li>\n</ul>\n",
        "likes": 13176,
        "dislikes": 460,
        "stats": "{\"totalAccepted\": \"1M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 1032354, \"totalSubmissionRaw\": 2735466, \"acRate\": \"37.7%\"}",
        "similarQuestions": "[{\"title\": \"Valid Parentheses\", \"titleSlug\": \"valid-parentheses\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/longest-valid-parentheses/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "33",
        "questionFrontendId": "33",
        "title": "Search in Rotated Sorted Array",
        "content": "<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>\n\n<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly left rotated</strong> at an unknown index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be left rotated by&nbsp;<code>3</code>&nbsp;indices and become <code>[4,5,6,7,0,1,2]</code>.</p>\n\n<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of </em><code>target</code><em> if it is in </em><code>nums</code><em>, or </em><code>-1</code><em> if it is not in </em><code>nums</code>.</p>\n\n<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0\n<strong>Output:</strong> 4\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3\n<strong>Output:</strong> -1\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1], target = 0\n<strong>Output:</strong> -1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>All values of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is an ascending array that is possibly rotated.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 29450,
        "dislikes": 1783,
        "stats": "{\"totalAccepted\": \"4.2M\", \"totalSubmission\": \"9.5M\", \"totalAcceptedRaw\": 4155053, \"totalSubmissionRaw\": 9465046, \"acRate\": \"43.9%\"}",
        "similarQuestions": "[{\"title\": \"Search in Rotated Sorted Array II\", \"titleSlug\": \"search-in-rotated-sorted-array-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Minimum in Rotated Sorted Array\", \"titleSlug\": \"find-minimum-in-rotated-sorted-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Pour Water Between Buckets to Make Water Levels Equal\", \"titleSlug\": \"pour-water-between-buckets-to-make-water-levels-equal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "34",
        "questionFrontendId": "34",
        "title": "Find First and Last Position of Element in Sorted Array",
        "content": "<p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p>\n\n<p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>\n\n<p>You must&nbsp;write an algorithm with&nbsp;<code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 8\n<strong>Output:</strong> [3,4]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 6\n<strong>Output:</strong> [-1,-1]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [], target = 0\n<strong>Output:</strong> [-1,-1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums</code> is a non-decreasing array.</li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 22891,
        "dislikes": 623,
        "stats": "{\"totalAccepted\": \"3.1M\", \"totalSubmission\": \"6.4M\", \"totalAcceptedRaw\": 3100503, \"totalSubmissionRaw\": 6448282, \"acRate\": \"48.1%\"}",
        "similarQuestions": "[{\"title\": \"First Bad Version\", \"titleSlug\": \"first-bad-version\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Plates Between Candles\", \"titleSlug\": \"plates-between-candles\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Target Indices After Sorting Array\", \"titleSlug\": \"find-target-indices-after-sorting-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "35",
        "questionFrontendId": "35",
        "title": "Search Insert Position",
        "content": "<p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>\n\n<p>You must&nbsp;write an algorithm with&nbsp;<code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,6], target = 5\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,6], target = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,6], target = 7\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> contains <strong>distinct</strong> values sorted in <strong>ascending</strong> order.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 18432,
        "dislikes": 876,
        "stats": "{\"totalAccepted\": \"4.4M\", \"totalSubmission\": \"8.8M\", \"totalAcceptedRaw\": 4430606, \"totalSubmissionRaw\": 8791897, \"acRate\": \"50.4%\"}",
        "similarQuestions": "[{\"title\": \"First Bad Version\", \"titleSlug\": \"first-bad-version\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Exceed Threshold Value I\", \"titleSlug\": \"minimum-operations-to-exceed-threshold-value-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/search-insert-position/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "36",
        "questionFrontendId": "36",
        "title": "Valid Sudoku",
        "content": "<p>Determine if a&nbsp;<code>9 x 9</code> Sudoku board&nbsp;is valid.&nbsp;Only the filled cells need to be validated&nbsp;<strong>according to the following rules</strong>:</p>\n\n<ol>\n\t<li>Each row&nbsp;must contain the&nbsp;digits&nbsp;<code>1-9</code> without repetition.</li>\n\t<li>Each column must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>\n\t<li>Each of the nine&nbsp;<code>3 x 3</code> sub-boxes of the grid must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>\n</ol>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>\n\t<li>Only the filled cells need to be validated according to the mentioned&nbsp;rules.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" style=\"height:250px; width:250px\" />\n<pre>\n<strong>Input:</strong> board = \n[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]\n,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]\n,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]\n,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]\n,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> board = \n[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]\n,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]\n,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]\n,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]\n,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Same as Example 1, except with the <strong>5</strong> in the top left corner being modified to <strong>8</strong>. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> is a digit <code>1-9</code> or <code>&#39;.&#39;</code>.</li>\n</ul>\n",
        "likes": 12305,
        "dislikes": 1253,
        "stats": "{\"totalAccepted\": \"2.4M\", \"totalSubmission\": \"3.7M\", \"totalAcceptedRaw\": 2365031, \"totalSubmissionRaw\": 3696866, \"acRate\": \"64.0%\"}",
        "similarQuestions": "[{\"title\": \"Sudoku Solver\", \"titleSlug\": \"sudoku-solver\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Check if Every Row and Column Contains All Numbers\", \"titleSlug\": \"check-if-every-row-and-column-contains-all-numbers\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/valid-sudoku/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "37",
        "questionFrontendId": "37",
        "title": "Sudoku Solver",
        "content": "<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>\n\n<p>A sudoku solution must satisfy <strong>all of the following rules</strong>:</p>\n\n<ol>\n\t<li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li>\n\t<li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li>\n\t<li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li>\n</ol>\n\n<p>The <code>&#39;.&#39;</code> character indicates empty cells.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" style=\"height:250px; width:250px\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Output:</strong> [[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Explanation:</strong>&nbsp;The input board is shown above and the only valid solution is shown below:\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png\" style=\"height:250px; width:250px\" />\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> is a digit or <code>&#39;.&#39;</code>.</li>\n\t<li>It is <strong>guaranteed</strong> that the input board has only one solution.</li>\n</ul>\n",
        "likes": 10934,
        "dislikes": 337,
        "stats": "{\"totalAccepted\": \"973.5K\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 973503, \"totalSubmissionRaw\": 1489339, \"acRate\": \"65.4%\"}",
        "similarQuestions": "[{\"title\": \"Valid Sudoku\", \"titleSlug\": \"valid-sudoku\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Unique Paths III\", \"titleSlug\": \"unique-paths-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "For each cell, place a valid number and try solving for the remaining empty cells.",
          "If stuck, undo (backtrack) and try another valid number."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/sudoku-solver/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "38",
        "questionFrontendId": "38",
        "title": "Count and Say",
        "content": "<p>The <strong>count-and-say</strong> sequence is a sequence of digit strings defined by the recursive formula:</p>\n\n<ul>\n\t<li><code>countAndSay(1) = &quot;1&quot;</code></li>\n\t<li><code>countAndSay(n)</code> is the run-length encoding of <code>countAndSay(n - 1)</code>.</li>\n</ul>\n\n<p><a href=\"http://en.wikipedia.org/wiki/Run-length_encoding\" target=\"_blank\">Run-length encoding</a> (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string <code>&quot;3322251&quot;</code> we replace <code>&quot;33&quot;</code> with <code>&quot;23&quot;</code>, replace <code>&quot;222&quot;</code> with <code>&quot;32&quot;</code>, replace <code>&quot;5&quot;</code> with <code>&quot;15&quot;</code> and replace <code>&quot;1&quot;</code> with <code>&quot;11&quot;</code>. Thus the compressed string becomes <code>&quot;23321511&quot;</code>.</p>\n\n<p>Given a positive integer <code>n</code>, return <em>the </em><code>n<sup>th</sup></code><em> element of the <strong>count-and-say</strong> sequence</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 4</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;1211&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\ncountAndSay(1) = &quot;1&quot;\ncountAndSay(2) = RLE of &quot;1&quot; = &quot;11&quot;\ncountAndSay(3) = RLE of &quot;11&quot; = &quot;21&quot;\ncountAndSay(4) = RLE of &quot;21&quot; = &quot;1211&quot;\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 1</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;1&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>This is the base case.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it iteratively?",
        "likes": 5023,
        "dislikes": 9013,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"2.2M\", \"totalAcceptedRaw\": 1353309, \"totalSubmissionRaw\": 2181005, \"acRate\": \"62.0%\"}",
        "similarQuestions": "[{\"title\": \"Encode and Decode Strings\", \"titleSlug\": \"encode-and-decode-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"String Compression\", \"titleSlug\": \"string-compression\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Create a helper function that maps an integer to pairs of its digits and their frequencies. For example, if you call this function with \"223314444411\", then it maps it to an array of pairs [[2,2], [3,2], [1,1], [4,5], [1, 2]].",
          "Create another helper function that takes the array of pairs and creates a new integer. For example, if you call this function with [[2,2], [3,2], [1,1], [4,5], [1, 2]], it should create \"22\"+\"23\"+\"11\"+\"54\"+\"21\" = \"2223115421\".",
          "Now, with the two helper functions, you can start with \"1\" and call the two functions alternatively n-1 times. The answer is the last integer you will obtain."
        ],
        "topicTags": [
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/count-and-say/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "39",
        "questionFrontendId": "39",
        "title": "Combination Sum",
        "content": "<p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of </em><code>candidates</code><em> where the chosen numbers sum to </em><code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p>\n\n<p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the <span data-keyword=\"frequency-array\">frequency</span> of at least one of the chosen numbers is different.</p>\n\n<p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,3,6,7], target = 7\n<strong>Output:</strong> [[2,2,3],[7]]\n<strong>Explanation:</strong>\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,3,5], target = 8\n<strong>Output:</strong> [[2,2,2,2],[2,3,3],[3,5]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2], target = 1\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candidates.length &lt;= 30</code></li>\n\t<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>\n\t<li>All elements of <code>candidates</code> are <strong>distinct</strong>.</li>\n\t<li><code>1 &lt;= target &lt;= 40</code></li>\n</ul>\n",
        "likes": 20691,
        "dislikes": 525,
        "stats": "{\"totalAccepted\": \"2.9M\", \"totalSubmission\": \"3.9M\", \"totalAcceptedRaw\": 2942638, \"totalSubmissionRaw\": 3878658, \"acRate\": \"75.9%\"}",
        "similarQuestions": "[{\"title\": \"Letter Combinations of a Phone Number\", \"titleSlug\": \"letter-combinations-of-a-phone-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Combination Sum II\", \"titleSlug\": \"combination-sum-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Combinations\", \"titleSlug\": \"combinations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Combination Sum III\", \"titleSlug\": \"combination-sum-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Factor Combinations\", \"titleSlug\": \"factor-combinations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Combination Sum IV\", \"titleSlug\": \"combination-sum-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"The Number of Ways to Make the Sum\", \"titleSlug\": \"the-number-of-ways-to-make-the-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/combination-sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "40",
        "questionFrontendId": "40",
        "title": "Combination Sum II",
        "content": "<p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code>&nbsp;where the candidate numbers sum to <code>target</code>.</p>\n\n<p>Each number in <code>candidates</code>&nbsp;may only be used <strong>once</strong> in the combination.</p>\n\n<p><strong>Note:</strong>&nbsp;The solution set must not contain duplicate combinations.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [10,1,2,7,6,1,5], target = 8\n<strong>Output:</strong> \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,5,2,1,2], target = 5\n<strong>Output:</strong> \n[\n[1,2,2],\n[5]\n]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;candidates.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;candidates[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n",
        "likes": 12072,
        "dislikes": 377,
        "stats": "{\"totalAccepted\": \"1.6M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 1602483, \"totalSubmissionRaw\": 2727374, \"acRate\": \"58.8%\"}",
        "similarQuestions": "[{\"title\": \"Combination Sum\", \"titleSlug\": \"combination-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]  \n\n## Solution\n\n---\n\n### Overview\n\nThis is one of the problems in the series of combination sums. All these problems can be solved with the same backtracking algorithm.\n\nWe recommend trying these similar problems before tackling this one: [Combination Sum](https://leetcode.com/problems/combination-sum/description/) and [Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/), which are arguably easier and one can tweak the solution a bit to solve this problem.\n\nWe also listed some follow-up problems at the end of the article if you are interested in exploring the bactracking algorithm further.\n\n---\n\n### Approach: Backtracking\n\n#### Intuition\n\nIn this problem, we need to generate unique combinations with the given sum value. In the worst case, we might need to generate the sum of all combinations in the array. Backtracking can be effectively used to generate all the possible combinations recursively. Backtracking incrementally builds candidates to the solutions and abandons a candidate (backtracks) as soon as it determines that this candidate can't lead to a final solution. For example, in the given problem, we can discard the candidate solution when it exceeds the sum value, provided the array contains non-negative values. Refer to this [backtracking explore card](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/) to read more about backtracking.\n\nUsing backtracking, we could incrementally build the combinations. When we find the current combination is not valid, we backtrack and try another option. For the first option, we add the current array element to the current combination array and move this combination to the next index recursively. Similarly, for the second option, we remove the element from the current combination array and move this combination to the next index. Therefore, for every index, we explored two possibilities of including and excluding that value and calculated the combination sum of the maintained combination array. If the desired sum is reached, we can append the list to the answer list. To demonstrate the idea, we showcase how it works with a concrete example in the following tree:\n\n![fig](../Figures/40/40.png)\n\nAre there any optimizations to reduce the backtracking calls? Since we need to return unique combinations, we can group equal values of the array together. The simplest way to group all elements together is by sorting them. Now, suppose the frequency of an element is `freq`, and you need to make backtracking calls for all its possible frequencies between `0` and `freq`, then we can simply pick them from the beginning of its group in the sorted array.\n\n#### Algorithm\n\n- Create a list `list` to store all the unique combinations that sum up to the target.\n- Sort the `candidates` array to handle duplicates and facilitate the backtracking process.\n- Call the `backtrack` function with the following parameters:\n  - `answer`: List to store the final combinations.\n  - `tempList`: Temporary list to store the current combination.\n  - `candidates`: Input array of numbers.\n  - `totalLeft`: Remaining sum to reach the target.\n  - `index`: Starting index for the current recursion.\n\n- Within the `backtrack` function:\n  - If `totalLeft` is less than 0, return immediately (invalid path).\n  - If `totalLeft` equals 0:\n    - Add a copy of `tempList` to `answer` (valid combination found).\n  - Otherwise:\n    - Iterate over `candidates` starting from `index`:\n      - Skip duplicate numbers by checking if `candidates[i] == candidates[i - 1]` for `i > index`.\n      - Add `candidates[i]` to `tempList`.\n      - Recursively call `backtrack` with:\n        - Updated `totalLeft` reduced by `candidates[i]`.\n        - Updated `index` as `i + 1` to avoid reusing the same element.\n      - Remove the last element from `tempList` to backtrack and explore other possibilities.\n\n- Return `list` containing all unique combinations after the recursive calls complete.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/SGfPMJBF/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"SGfPMJBF\"></iframe>\n\n#### Complexity Analysis\n\nLet $N$ be the number of $candidates$ in the array.\n\n- Time complexity: $O(2^N)$\n\n    In the worst case, our algorithm will exhaust all possible combinations from the input array. Again, in the worst case, let us assume that each number is unique. The number of combinations for an array of size $N$ would be $2^N$, i.e. each number is included or excluded in a combination. \n    \n    Additionally, it takes $O(N)$ time to build a counter table out of the input array.\n    \n    Therefore, the overall time complexity of the algorithm is dominated by the backtracking process, which is $O(2^N)$.\n\n    You must think about how the solution passes the test cases when the value of $N$ goes up to 100. [Pruning](https://en.wikipedia.org/wiki/Decision_tree_pruning) is the process of writing some additional conditions within our recursion code that help us to reduce the size of our recursion trees by removing redundant sections. For example, in this problem, the maximum value of any `candidates` element is given by 50, whereas the maximum `target` value is 30. So, we can stop the recursion when the value of candidates exceeds the `target` value. Sorting the array is another way to prune the recursion tree. Checkout the image for an explanation:\n\n    ![fig](../Figures/40/image.png)\n   \n- Space complexity: $O(N)$\n   \n    We first create a `tempList`, which in the worst case will consume $O(N)$ space to keep track of the combinations. In addition, we apply recursion in the algorithm, which will incur additional memory consumption in the function call stack. In the worst case, the stack will pile up to $O(N)$ space.\n\n    To sum up, the overall space complexity of the algorithm is $O(N)$.\n\n    Note: we did not take into account the space needed to hold the final results of the combination in the above analysis.\n\n---\n\nHere are a series of problems you can solve, with some tweaks of the backtracking algorithm presented in this article.\n\n[Subsets](https://leetcode.com/problems/subsets/description/)\n[Subsets II](https://leetcode.com/problems/subsets-ii/description/)\n[Permutations](https://leetcode.com/problems/permutations/description/)\n[Permutations II](https://leetcode.com/problems/permutations-ii/description/)\n[Combinations](https://leetcode.com/problems/combinations/description/)\n[Combination Sum](https://leetcode.com/problems/combination-sum/description/)\n[Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/)\n[Palindrome Partition](https://leetcode.com/problems/palindrome-partitioning/description/)\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/combination-sum-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "41",
        "questionFrontendId": "41",
        "title": "First Missing Positive",
        "content": "<p>Given an unsorted integer array <code>nums</code>. Return the <em>smallest positive integer</em> that is <em>not present</em> in <code>nums</code>.</p>\n\n<p>You must implement an algorithm that runs in <code>O(n)</code> time and uses <code>O(1)</code> auxiliary space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,0]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The numbers in the range [1,2] are all in the array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,-1,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 1 is in the array but 2 is missing.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,8,9,11,12]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The smallest positive integer 1 is missing.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 18151,
        "dislikes": 1972,
        "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"3.9M\", \"totalAcceptedRaw\": 1658165, \"totalSubmissionRaw\": 3929394, \"acRate\": \"42.2%\"}",
        "similarQuestions": "[{\"title\": \"Missing Number\", \"titleSlug\": \"missing-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Duplicate Number\", \"titleSlug\": \"find-the-duplicate-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find All Numbers Disappeared in an Array\", \"titleSlug\": \"find-all-numbers-disappeared-in-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Couples Holding Hands\", \"titleSlug\": \"couples-holding-hands\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Smallest Number in Infinite Set\", \"titleSlug\": \"smallest-number-in-infinite-set\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Integers to Choose From a Range I\", \"titleSlug\": \"maximum-number-of-integers-to-choose-from-a-range-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest Missing Non-negative Integer After Operations\", \"titleSlug\": \"smallest-missing-non-negative-integer-after-operations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Integers to Choose From a Range II\", \"titleSlug\": \"maximum-number-of-integers-to-choose-from-a-range-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest Missing Integer Greater Than Sequential Prefix Sum\", \"titleSlug\": \"smallest-missing-integer-greater-than-sequential-prefix-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Think about how you would solve the problem in non-constant space.  Can you apply that logic to the existing space?",
          "We don't care about duplicates or non-positive integers",
          "Remember that O(2n) = O(n)"
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nThe task is to find the smallest positive integer that is not present in `nums`.\n\nNote that positive integers are greater than zero.\n\nLet's discuss the two main cases:\n\n**1. No Missing Integer in `nums`:**\n\n| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n|---|---|---|---|---|---|---|---|---|\n\n`nums` contains `9` elements. The smallest missing positive integer is `10`.\n\nFor an array of length `n`, if the array contains all of the integers in the range `1` to `n`, the smallest missing positive integer is `n + 1`.\n\n**2. Missing Integer in `nums`:**\n\n|-10 | 1 | 2 | 2 | 3 | 4 | 6 | 6 | 8 |\n|----|---|---|---|---|---|---|---|---|\n\n`nums` contains `9` elements. The smallest missing positive integer is `5`.\n\nFor an array of length `n`, if the array does not contain all of the integers in the range `1` to `n`, the smallest missing positive integer is the first integer missing from that range.\n\nLet's also discuss the constraints:\n\n> You must implement an algorithm that runs in $O(n)$ time and uses $O(1)$ auxiliary space.\n\n**1. Time Complexity:**\n\nHint number three reminds us that $O(2n) = O(n)$. While we know that one does not equal two, $O$ notation describes an algorithm's limiting behavior as the input size grows toward infinity.\n\n**2. Space Complexity:**\n\nThe optimized approaches in this article use in-place solutions. Does in-place mean a constant space complexity? By [definition](https://en.wikipedia.org/wiki/In-place_algorithm), an in-place algorithm transforms the input using no auxiliary data structures proportional to the input size. An in-place algorithm does not necessarily mean constant space complexity; for example, an in-place recursive algorithm uses the recursion stack, so the space is not constant.\n\nThe problem specifically asks us to use constant *auxiliary* space, so in-place solutions meet this criterion.\n\n---\n\n### Approach 1: Boolean Array\n\n#### Intuition\n\nWe can solve the problem by iterating through the numbers `1` to `n`, and use linear search to determine whether each number is in the array. The first number we cannot find is the smallest missing integer. This approach would result in a quadratic time complexity.\n\nWe need to determine whether an element is in the array in constant time. Array indexing provides constant lookup time. We need to check the existence of a relatively small range of values, positive numbers between `1` and `n`, so we can use an array like a hash table by using the index as a key and the value as a presence indicator. The default value is `false`, which represents a missing number, and we set the value to `true` for keys that exist in `nums`. Numbers not in the range `1` to `n` are not relevant in the search for the first missing positive, so we do not mark them in the `seen` array.\n\nTo solve the problem, we can create an array of size `n + 1`. For each positive number less than `n` in `nums`, we set `seen[num]` to `true`. Then, we iterate through the integers `1` to `n` and return the first number that is not marked as seen in the array. If the array contains all of the elements `1` to `n`, we return `n + 1`.\n\n> **Note:** This approach does not meet the problem constraint of solving the problem using constant auxiliary space. It is included to make the solution accessible, and it can provide valuable background for solving the problem within the space constraints. Other approaches that do not meet the time and/or space constraints are not included as they are less relevant to understanding the following approaches.\n\n#### Algorithm\n\n1. Initialize a variable `n` to the length of `nums`.\n\n2. Initialize an array `seen` to size `n + 1`.\n\n3. Mark the elements in `nums` as seen in the array `seen`.\n\n    - For each `num` in `nums`, if `num` is greater than `0` and less than or equal to `n`, set `seen[num]` to `true`.\n\n4. Find the smallest missing positive number:\n\n    - For `i` from `1` to `n`, If `seen[i]` is not `true`, return `i`, the smallest missing integer.\n\n5. If `seen` contains all elements `1` to `n`, return `n + 1` as the smallest missing positive number.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/ASLfPBW8/shared\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"ASLfPBW8\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of `nums`.\n\n* Time complexity: $O(n)$\n\n    Marking the values from `nums` in `seen` takes $O(n)$.\n\n    We check for values `1` to `n` in `seen`, which takes $O(n)$.\n\n    The total time complexity will be $O(2n)$, which we can simplify to $O(n)$.\n\n* Space complexity: $O(n)$\n\n    We initialize the array `seen`, which is size `n + 1`, so the space complexity is $O(n)$.\n\n---\n\n### Approach 2: Index as a Hash Key\n\n#### Intuition\n\n**Data Clean Up**\n\nOur search for the first missing positive focuses on the elements with values `1` through `n`. Negative numbers, zeros, and numbers larger than `n` are not relevant. Let's replace all these with `1`s. \n\n![max_first](../Figures/41/41_replace.png)\n\nTo ensure that the first missing positive is not `1`, we also have to track whether `1` exists in the original array.\n\n**Solving In-Place**\n\nNow we have an array that contains only positive numbers in a range from `1` to `n`, and the goal is to find the first missing positive in linear time and constant auxiliary space. \n\nIn the above approach, using the `seen` array introduced extra space. We can utilize `nums` itself to track which positive integers occur in the array since the range of numbers we have now is the same as the length of the array. We can use the index as a hash key for a positive number, and the sign of the element as a presence indicator.\n\nFor example, the negative sign of `nums[5]` means that the number `5` is present in `nums`. The positive sign of `nums[6]` means that the number `6` is not present (missing) in `nums`.\n\n![max_first](../Figures/41/41_true_solution.png)\n\nTo determine the smallest missing positive, we traverse the array, check each element value `value`, and change the sign of element `nums[value]` to negative to mark the number `value` as present in `nums`. We must be careful with duplicates and ensure that the sign is changed only once.\n\n> **Interview Tip: In-place Algorithms**\n>\n> This approach modifies the input by changing values of `nums`. In-place algorithms overwrite the input to save space, but sometimes this can cause problems.\n>\n> Here are a couple of situations where an in-place algorithm might not be suitable.\n>\n> 1. The algorithm needs to run in a multi-threaded environment, without exclusive access to the array. Other threads might need to read the array too, and might not expect it to be modified.\n>\n> 2. Even if there is only a single thread, or the algorithm has exclusive access to the array while running, the array might need to be reused later or by another thread once the lock has been released.\n>\n> In an interview, you should always check whether the interviewer minds you overwriting the input. Be ready to explain the pros and cons of doing so if asked!\n\n#### Algorithm\n\n1. Initialize a variable `n` to the length of `nums`, and a boolean `contains1` to `false`.\n\n2. Traverse `nums`, check whether `1` occurs, and replace negative numbers, zeros, and numbers larger than `n` with `1`. For each element in nums:\n\n    - If the element equals `1`, set `contains1` to `true`.\n    - If the element is less than or equal to `0` or greater than `n`, replace it with `1`.\n\n3. If the original `nums` array does not contain `1`, return `1`.\n\n4. Traverse `nums` using a `for` loop from `i` equals `0` to `n`. When `value` is encountered, flip the sign of the number at index `value` to negative to indicate that it is present in the array. Use absolute value to prevent duplicate occurrences of `value` from flipping the sign back to positive.\n    - Set an integer `value` to the absolute value of `nums[i]`.\n    - If `value` equals `n`, we use index `0` to save information about the presence of the number `n` since index `n` is not available. Set `nums[0]` to the negative of the absolute value of `nums[0]`.\n    - Otherwise, we use index `value` to store information about the presence of the number `value`. Set `nums[value]` to the negative of the absolute value of `nums[value]`.\n\n5. Find the smallest missing positive number:\n\n    - Iterate through the integers `1` to `n` using iterator `i`. If `nums[i]` is positive, return `i`.\n\n6. If `nums[0]` is greater than `0` return `n`.\n\n7. If `nums` contains all elements `1` to `n`, return `n + 1` as the smallest missing positive number.\n\n!?!../Documents/41_LIS.json:1000,589!?!\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/PppX77uq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"PppX77uq\"></iframe>\n\n#### Complexity Analysis\n\nLet $n$ be the length of `nums`,\n\n* Time complexity: $O(n)$\n\n    We traverse `nums` using a `for` loop three separate times, so the time complexity is $O(n)$.\n\n* Space complexity: $O(n)$\n\n    We modify the array `nums` and use it to determine the answer, so the space complexity is $O(n)$.\n\n    `nums` is the input array, so the *auxiliary* space used is $O(1)$.\n\n---\n\n### Approach 3: Cycle Sort\n\n#### Intuition\n\nIn the first approach, we discussed that we can solve the problem by iterating through the numbers `1` to `n` and searching for each in the array. If `nums` were sorted, this search process could be done in linear time. The built-in sorting functions in most major languages use linear or logarithmic auxiliary space. We need a way to sort the array in-place, in constant time.\n\nThe numbers we need to check for are in the range `1` to `n`, so we can utilize [cycle sort](https://en.wikipedia.org/wiki/Cycle_sort). Cycle sort is a sorting algorithm that can sort a given sequence in a range from `a` to `n` by putting each element at the index that corresponds to its value.\n\n`nums` is a zero-indexed array, so an element with the value `x` will be located at index `x - 1`. For example, `1` goes at index `0` in the array, `2` goes at index `1`, and `100` goes at index `99`. \n\nFor each element `x` in `nums`, if it is a positive integer between `1` and `n`, we place it at index `nums[x - 1]`. Elements smaller than `1` or larger than `n` will reside at indexes that do not have a corresponding value in `nums`.\n\nThen, to determine the smallest positive integer, we iterate through `nums`, and return the first element that is not equal to its index plus one.\n\nIf we iterate through the whole sorted array without returning a value, the array consists of the sequence of numbers `1` through `n`, so we return `n + 1`.\n\n> **Notes:** \n>   - This approach modifies the input. It changes the order of `nums`, but not the values of `nums`. In-place algorithms overwrite the input to save space, but sometimes this can cause problems. Always check with your interviewer before modifying the input.\n>\n>   - We use a simplified version of cycle sort because it is not a problem if the duplicate of a value is not in the correct position.\n\n#### Algorithm\n\n1. Initialize a variable `n` to the length of `nums`.\n\n2. Use cycle sort to place positive elements smaller than `n` at the correct index.\n\n    - Initialize a variable `i` to `0`.\n    - Iterate through the elements in `nums`:\n        - Set a variable `correctIdx` to `nums[i] - 1`.\n        - If the `nums[i]` is greater than zero, less than or equal to `n`, and does not equal `nums[correctIdx]`, swap the element at `nums[i]` with the element at `nums[correctIdx]`.\n        - Otherwise, increment `i`.\n\n3. Iterate through sorted `nums` and return the smallest missing positive number.\n\n    - For each element in `nums`, if `nums[i]` does not equal `i + 1`, return `i + 1`, the smallest missing positive number.\n\n4. Return `n + 1`, the smallest missing positive number when each number in `nums` is in the correct position.\n\n!?!../Documents/41/41_slideshow.json:960,540!?!\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/efsbaqYc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"efsbaqYc\"></iframe>\n\n> **Note:** The variable `correctIdx` is included in the Python3 and Java implementations for readability. The C++ version directly uses `nums[i] - 1` to prevent integer overflow.\n\n#### Complexity Analysis\n\nLet $n$ be the length of `nums`.\n\n* Time complexity: $O(n)$\n\n    We loop through the elements in `nums` once, swapping elements to sort the array. Swapping takes constant time. Sorting `nums` using cycle sort takes $O(n)$ time. \n    \n    Iterating through the sorted array and finding the first missing positive can take up to $O(n)$. \n    \n    The total time complexity is $O(2n)$, which simplifies to $O(n)$.\n\n\n* Space complexity: $O(n)$\n\n    We modify the array `nums` and use it to determine the answer, so the space complexity is $O(n)$.\n\n    `nums` is the input array, so the *auxiliary* space used is $O(1)$.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/first-missing-positive/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "42",
        "questionFrontendId": "42",
        "title": "Trapping Rain Water",
        "content": "<p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png\" style=\"width: 412px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> height = [0,1,0,2,1,0,1,3,2,1,2,1]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> height = [4,2,0,3,2,5]\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 35772,
        "dislikes": 671,
        "stats": "{\"totalAccepted\": \"3.3M\", \"totalSubmission\": \"5M\", \"totalAcceptedRaw\": 3304398, \"totalSubmissionRaw\": 4968107, \"acRate\": \"66.5%\"}",
        "similarQuestions": "[{\"title\": \"Container With Most Water\", \"titleSlug\": \"container-with-most-water\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Product of Array Except Self\", \"titleSlug\": \"product-of-array-except-self\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Trapping Rain Water II\", \"titleSlug\": \"trapping-rain-water-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Pour Water\", \"titleSlug\": \"pour-water\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Value of an Ordered Triplet II\", \"titleSlug\": \"maximum-value-of-an-ordered-triplet-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Monotonic Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/trapping-rain-water/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "43",
        "questionFrontendId": "43",
        "title": "Multiply Strings",
        "content": "<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>\n\n<p><strong>Note:</strong>&nbsp;You must not use any built-in BigInteger library or convert the inputs to integer directly.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> num1 = \"2\", num2 = \"3\"\n<strong>Output:</strong> \"6\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> num1 = \"123\", num2 = \"456\"\n<strong>Output:</strong> \"56088\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li>\n\t<li><code>num1</code> and <code>num2</code> consist of digits only.</li>\n\t<li>Both <code>num1</code> and <code>num2</code>&nbsp;do not contain any leading zero, except the number <code>0</code> itself.</li>\n</ul>\n",
        "likes": 7651,
        "dislikes": 3654,
        "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"2.5M\", \"totalAcceptedRaw\": 1097756, \"totalSubmissionRaw\": 2531202, \"acRate\": \"43.4%\"}",
        "similarQuestions": "[{\"title\": \"Add Two Numbers\", \"titleSlug\": \"add-two-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Plus One\", \"titleSlug\": \"plus-one\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add Binary\", \"titleSlug\": \"add-binary\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add Strings\", \"titleSlug\": \"add-strings\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Apply Discount to Prices\", \"titleSlug\": \"apply-discount-to-prices\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "String"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nWe are given two non-negative integers that are represented as strings and asked to return the product of the two integers, also in the form of a string. There are a few subtle challenges and edge cases that we must consider to solve this problem.  So, before determining how to multiply two numbers in string format, let's first consider a simpler variation of the problem: adding two numbers in string format.  \nWe can add two numbers represented as strings by adding digits from the given numbers in each place.  The sum of two digits must be between 0 and 18. The ones place is added to the result while the tens place is carried and summed with the next pair of digits. When summing two numbers, the carried digit will always be zero or one. This process can be repeated for each digit, as shown below.\n\n![image](../Figures/43/Slide31.JPG)\n\nWhy does learning how to add two integers represented as strings help us solve this problem? As we will soon see, addition is a subproblem of multiplication. Thus we will need to be able to solve the problem of adding two numbers as strings before we can solve the problem of multiplying two numbers as strings.\n\nIf this type of problem is new to you and you would like to practice by solving similar problems, we have provided the list below: \n1. [66. Plus One](https://leetcode.com/problems/plus-one/)      \n2. [67. Add Binary](https://leetcode.com/problems/add-binary/)      \n3. [415. Add Strings](https://leetcode.com/problems/add-strings/)  \n4. [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/)     \n\n\n---\n\n### Approach 1: Elementary Math\n\n#### Intuition\n\nOur goal is to multiply two integer numbers that are represented as strings. However, we are not allowed to use a built-in BigInteger library or convert the inputs to integers directly. So how can we multiply the two input strings? We can try to break the problem down into manageable chunks, as is done in elementary mathematics.  Thus, we will focus on one digit at a time, just like in the addition example, except here we will be multiplying both numbers digit by digit.  \n\n**Now, let's recall the process for multiplying two numbers.**      \nWe take the ones place digit of the second number, then multiply it with all digits of the first number consequently going backward, and write the result. We need to remember about carry as well. Note that for multiplication, carry may be any digit between 0 and 8.\n\n![image](../Figures/43/Slide1.JPG)\n\n<br />\n\nThen we take the tens place digit of the second number and multiply it with all digits of the first number.  Since we used the tens place digit, we will multiply this result by 10.  Then we write this result below the previous result, signifying that we will **add** it to the previous result later.\n\n![image](../Figures/43/Slide2.JPG)\n\n<br />\n\nThen we continue the same way with hundreds place digit, then with thousands place digit of the second number, and so on, until we have visited every digit in the second number.\n\n![image](../Figures/43/Slide3.JPG)\n\n<br />\n\nAs is evident from the above diagram, this process is equivalent to multiplying each digit of the second number by the entire first number and appending zeros at the end of each intermediate result based on the place in the second number that the digit came from.\nThen we add all the results together to get the final product of the first and second numbers.\n\n![image](../Figures/43/Slide4.JPG)\n\n<br />\n\nLet's look at an example. Consider $$123 * 456$$, it can be written as,\n\n$$\\implies (123 * (6 + 50 + 400))$$      \n$$\\implies (123 * 6) + (123 * 50) + (123 * 400)$$     \n$$\\implies (123 * 6) + (123 * 5 * 10) + (123 * 4 * 100)$$     \n \n$$\\implies \\Sigma \\space ( firstNumber * j^{th} \\space digit \\space of \\space secondNumber * 10^{(index \\space j \\space of \\space digit \\space counting \\space from \\space the \\space end)} )$$      \n\nThe results of the multiplication of each digit of the second number with the first number can be stored in an array of strings, and then we can add all these strings to get the final product.     \n\n#### Algorithm\n\nMultiplication of both numbers starts from the ones place digit (the right-most digit), so we should start our multiplication from index `num2.size() - 1` and go to index `0`.  Alternatively, we can reverse both inputs and iterate from index `0` to index `num2.size() - 1`.\n\nFor each digit in `num2` that we multiply by `num1` we will get a new intermediate result.  This intermediate result (`currentResult`) will be stored in a list, string, or StringBuilder, depending on the language of choice.  To calculate each intermediate result, we will start by inserting the appropriate number of zeros according to the current digit's place in the second number (i.e. if it is the hundreds place, we append 2 zeros).  Then we will perform the multiplication step as demonstrated in the above diagrams. During this step, we will insert the lower place digits into the `currentResult` before the higher place digits.  Because we are pushing the lower place digits first and always appending to the end, our result will be in reverse order, so once the multiplication and addition steps are complete, we will need to reverse `answer` before returning.\n\nLet's walk through the steps one by one:\n\n1. Reverse both numbers.\n2. For each digit in `secondNumber`:\n    - Keep a `carry` variable, initially equal to `0`.\n    - Initialize `currentResult` array beginning with the appropriate number of zeros according to the place of the `secondNumber` digit.\n    - For each digit in `firstNumber`:\n        - Multiply the `secondNumber`'s digit and the `firstNumber`'s digit and add `carry` to the `multiplication`.\n        - Take the remainder of `multiplication` with `10` to get the last digit.\n        - Append the last digit to the `currentResult`.\n        - Divide `multiplication` by `10` to get the new value for `carry`.\n    - Append the remaining value for `carry` (if any) to the `currentResult`.\n    - Push the `currentResult` into the `results` array.\n3. Compute the cumulative sum over all the obtained arrays using the `ans` as an answer.\n4. Reverse `ans` and return it.\n\n!?!../Documents/43/slideshow1.json:960,540!?!\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/ecJN2cdc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ecJN2cdc\"></iframe>\n\n\n#### Complexity Analysis\n\nHere $$N$$ and $$M$$ are the number of digits in `num1` and `num2` respectively.\n\n* Time complexity: $$O(M^2 + M \\cdot N)$$.\n\n  During multiplication, we perform $$N$$ operations for each of the $$M$$ digits of the second number; this requires $$O(M \\cdot N)$$ time. Then we add each of the $$M$$ multiplication results (of length $$O(N + M)$$) to the answer string; this requires $$O(M \\cdot (M + N))$$ time.\n   \n  > When we multiply a number with one digit, the result's maximum length can be at most one more than the number's length _(We can see that when we multiply the max integer of `d` digits, i.e., `9...99` with `9`)_ and there can be at most (M-1) zeroes initially appended to the result. Hence, each result is of order $$O(N + M)$$.\n   \n  Summing the results requires iterating over the length of the current answer for each result.  Since the length of two numbers multiplied together cannot be longer than the sum of the lengths of the two numbers, iterating over each digit in the answer will take $$O(M + N)$$ time and we will do so $$M - 1$$ times (for all but one of the $$M$$ results). So this step takes $$O(M \\cdot (M + N))$$ time.  \n   \n  Finally, reversing the answer will require $$O(M + N)$$ time. Taking all steps into consideration, the total time complexity is $$O(M^2 + M \\cdot N)$$.\n\n* Space complexity: $$O(M^2 + M \\cdot N)$$.     \n\n  We store each result of multiplication for each digit of `num2` with `num1` in the results array. Each multiplication result can have at most $$N + M$$ length, and there will be $$M$$ such results. Thus the space complexity is $$O(M \\cdot (M + N))$$.\n    \n\n<br/>\n\n---\n\n### Approach 2: Elementary math using less intermediate space\n\n#### Intuition\n\nNotice that we are storing the multiplication result for every digit in `num2`. If we know the maximum size of the answer array ahead of time, we can add each multiplication result directly to the final answer. Thus, we can avoid using the extra space required by the `results` array.\n\nFirst, let's determine what the maximum size of the answer array would be.\n\nTry a few test cases on your own, multiply two numbers, count how many digits are in the result, and compare that to the number of digits in each number.  Notice that whenever two numbers with the number of digits $$N$$ and $$M$$ are multiplied, the result never exceeds $$(N+M)$$ digits. \n\nWe could readily accept that <strong>num1.length + num2.length \u2265 (num1 \u00b7 num2).length</strong> without rigorous proof. However, it never hurts to verify a relationship that was derived from observation before accepting it as a fact. Don't worry, you will not be expected to provide a proof like this during the interview, hence you can skip it if you want.\n\n<details>\n\n<summary> The proof that the length of the product of two numbers is always less than or equal to the sum of lengths of the two numbers is as follows: (click to show/hide) </summary>\n\n<br>\n\n> A number $$n$$ has digits, $$ d = 1 + \\lfloor log_{10}(n) \\rfloor $$.  \n   \nIts proof is:   \n> Suppose that $$n$$ has $$d$$ digits, then $$ 10^{d-1} \\leq n < 10^{d} $$, because $$ 10^{d} $$ is the smallest integer with $$d+1$$ digits.       \nNow take log base 10, then the inequality becomes $$ (d-1) \\leq \\log_{10}(n) < d $$.      \nNow everything between the range $$(d-1, \\space d)$$ is decimal part, so taking floor of $$ \\log_{10}(n) $$ we can eliminate all the decimal part and get, $$ (d-1) = \\lfloor \\log_{10}(n) \\rfloor $$. \n<br />           \nThus, $$d = \\lfloor \\log_{10}(n) \\rfloor + 1$$.\n\n<br />\n\nLet $$firstNumber$$ have $$N$$ digits and $$secondNumber$$ have $$M$$ digits.      \n\nLet $$product = firstNumber \\cdot secondNumber$$ have $$X$$ digits. So, number of digits in $$product$$ is,      \n           \n$$  \\implies X = 1 + \\lfloor log_{10}(result) \\rfloor   $$         \n$$  \\implies X = 1 + \\lfloor log_{10}(firstNumber \\cdot secondNumber) \\rfloor   $$         \n$$  \\implies X = 1 + \\lfloor log_{10}(firstNumber) + log_{10}(secondNumber) \\rfloor $$ <br />         \n                 \n\n> A real number $$a$$ can have two parts in it, integral $$(I)$$ and fractional $$(F)$$. $$a = I_{a} + F_{a}$$.    \n\nNow, let's say we have two real numbers $$a = I_{a} + F_{a} $$ and $$b = I_{b} + F_{b}$$. \n<br />     \n\n$$ \\lfloor a + b \\rfloor = \\lfloor I_{a} + F_{a} + I_{b} + F_{b} \\rfloor = I_{a} + I_{b} + \\lfloor F_{a} + F_{b} \\rfloor $$     \n$$ F_{a}, F_{b} $$ are fractional parts both always less than 1.           \n$$ 0 \\leq F_{a} + F_{b} < 2 $$.      \n$$ 0 \\leq \\lfloor F_{a} + F_{b} \\rfloor <= 1 $$. <br />       \n> So, $$ I_{a} + I_{b} \\leq \\lfloor a + b \\rfloor \\leq  I_{a} + I_{b} + 1$$. \n<br />     \n\nBut, $$ \\lfloor a \\rfloor + \\lfloor b \\rfloor = \\lfloor I_{a} + F_{a} \\rfloor + \\lfloor I_{b} + F_{b} \\rfloor = I_{a} + I_{b} + \\lfloor F_{a} \\rfloor + \\lfloor F_{b} \\rfloor $$     \n$$ F_{a}, F_{b} $$ are fractional parts both always less than $$ 1 $$.        \n$$ 0 \\leq F_{a}, \\space F_{b} < 1 $$.          \nHence, $$ \\lfloor F_{a} \\rfloor + \\lfloor F_{b} \\rfloor = 0 $$. <br />       \n> So, $$ \\lfloor a \\rfloor + \\lfloor b \\rfloor = I_{a} + I_{b} $$. \n\n> Hence we can conclude here that, <br />     \n> $$ \\lfloor a \\rfloor + \\lfloor b \\rfloor \\leq \\lfloor a + b \\rfloor \\leq \\lfloor a \\rfloor + \\lfloor b \\rfloor + 1 $$  \n\n<br />\n\nNumber of digits in,\n$$ firstNumber = N, \\space secondNumber = M, \\space product = X $$ <br />  \nIf $$ a = log_{10}(firstNumber) $$ and $$ b = log_{10}(secondNumber) $$.     \n\n$$ N = \\lfloor log_{10} (firstNumber) \\rfloor + 1 = \\lfloor a \\rfloor + 1$$     \n$$ M = \\lfloor log_{10} (secondNumber) \\rfloor + 1 = \\lfloor b \\rfloor + 1$$     \n$$ X = \\lfloor log_{10} (firstNumber) + log_{10} (secondNumber) \\rfloor + 1 = \\lfloor a + b \\rfloor + 1$$      \n<br />\n\n$$ \\lfloor a \\rfloor = N - 1, \\space  \\lfloor b \\rfloor = M - 1, \\space  \\lfloor a + b \\rfloor = X - 1,  $$ <br />        \n\nas, $$ \\lfloor a \\rfloor + \\lfloor b \\rfloor \\leq \\lfloor a + b \\rfloor \\leq \\lfloor a \\rfloor + \\lfloor b \\rfloor + 1 $$  \n\n$$ \\implies (N-1) + (M-1) \\leq (X - 1) \\leq (N-1) + (M-1) + 1 $$       \n$$ \\implies (N + M - 1) \\leq X \\leq (N + M) $$ \n\n> Hence, $$X$$ can never exceed $$ (N + M) $$. \n\n</details>\n\n<br />\n\nSo an answer string of size $$N + M$$ is guaranteed to be large enough to hold our final result.  Let's create one and initialize all of its values as zero.\nInstead of storing all results of multiplication of each digit of $$num2$$ with $$num1$$ like we did in Approach 1, we can directly add the current result to the answer string.      \n\n#### Algorithm\n\n1. Reverse both numbers.\n2. Initialize `ans` array with $$(N+M)$$ zeros.\n3. For each digit in `secondNumber`:\n    - Keep a `carry` variable, initially equal to `0`.\n    - Initialize an array (`currentResult`) that begins with some zeros based on the place of the digit in `secondNumber`.\n    - For each digit of `firstNumber`:\n        - Multiply `secondNumber's` digit and `firstNumber's` digit and add previous `carry` to the `multiplication`.\n        - Take the remainder of `multiplication` with `10` to get the last digit.\n        - Append the last digit to `currentResult` array.\n        - Divide the `multiplication` by `10` to obtain the new value for `carry`.\n    - After iterating over each digit in the first number, if `carry` is not zero, append `carry` to the `currentResult`.\n    - Add `currentResult` to the `ans`.\n4. If the last digit in `ans` is zero, before reversing `ans`, we must pop the zero from `ans`. Otherwise, there would be a leading zero in the final answer.\n5. Reverse `ans` and return it.\n\n!?!../Documents/43/slideshow2.json:960,540!?!\n\n#### Implementation\n\n\n<iframe src=\"https://leetcode.com/playground/aiu9hUhq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"aiu9hUhq\"></iframe>\n\n\n#### Complexity Analysis\n\nHere $$N$$ and $$M$$ are the number of elements in num 1 and num 2 strings.\n\n* Time complexity: $$O(M \\cdot (N+M))$$.     \n   - During multiplication, we perform `N` operations for each of the `M` digits of the second number, so we need $$O(M \\cdot N)$$ time for it.     \n   - We add the multiplication result to the `ans` string that has a length of $$N+M$$. There will be $$M$$ such additions since we have $$M$$ multiplication results. Therefore, the time consumed here will be $$O(M \\cdot (N+M))$$.\n   - It takes linear time to reverse the strings.\n   - Overall, this solution takes $$O(M \\cdot N + M \\cdot (N+M) + M + N) = O(M \\cdot (N+M))$$ time.\n\n* Space complexity: $$O(N + M)$$.     \n   - The answer string and multiplication results will have at most $$N + M$$ length.\n\n<br/>\n\n---\n\n### Approach 3: Sum the products from all pairs of digits\n\n#### Intuition\n\nAs we have seen in the previous approaches, when we multiply two digits, one from the first number and one from the second number, then their product will have some zeros appended at the end. The number of zeros depends on the place of each digit, and (as demonstrated in the image below) when the result is added to the answer, the trailing zeros do not affect the answer (because any number plus zero is itself).\nSo it is not necessary for us to append zeros at the end of each result before adding the result to the final answer. Instead, we can directly add the multiplication result at the place where the least significant digit will shift to after to appending some zeros.  \n\nAs an example, when we multiply two tens place digits, two zeros are appended at the end of the multiplication result, and the result will be added at the hundreds place in the final answer. One more example for clarity, if we multiplied a digit in the thousands place (3 trailing zeros) by a digit in the hundreds place (2 trailing zeros), the product will have 5 trailing zeros (the sum of trailing zeros of each digit) so the result will only affect the hundred thousands place and the millions place in the final answer.  \n\n![image](../Figures/43/Slide32.JPG)     \n\n<br />\n\nIn the previous solution, including the extra zeros was quite costly.  For instance, `multiplyOneDigit` stored these extra zeros for every intermediate result which required an additional $$O(N)$$ space and time for each multiplication, where $$N$$ is the number of digits in `num2`.  Furthermore, every time we called `multiplyOneDigit` we added the result to the current `answer`.  This involved iterating over all $$M + N$$ digits in answer each time we added a new result to the current answer. So let's get a better idea of how we can solve this problem without iterating over all the extra zeros.\n\nTake a moment to study the above example.  Notice that we multiply each digit in `num2` by each digit in `num1` just like before. Each time we will get a 2-digit result with some zeros after it. Since we know how many zeros will follow the product of the two digits based on their places, we know which two places in `answer` to update.  So, instead of updating all $$M + N$$ elements in `answer` for each of the $$N$$ digits in `num2`, we only need to update $$2$$ digits in `answer` for each of the $$M \\cdot N$$ pairs of digits.  The above example highlights the two digits from each result that we will add to the answer and the below example shows precisely how this will be done.\n\nThus, for each pair of digits, we multiply them together to get a 2-digit result. The ones place of the result will be added at the correct position in `answer` (based on the place of each of the digits). The tens place of the result will be added to the next place in `answer`. This step is effectively the same as carrying the tens place digit in the previous approaches.\n\nNote that the `answer` array will be reversed just like before. So when we multiply a digit in the $$i^{th}$$ place of the first number by a digit in the $$j^{th}$$ place of the second number, then the ones place of the result will add to the $$(i+j)^{th}$$ place in the final answer and the tens place of the result (carry) will be added to the $$(i+j+1)^{th}$$ place in the final answer. \n\n\n#### Algorithm\n\n1. Reverse both numbers.\n2. Initialize `answer` with $$N + M$$ zeros.\n3. For each digit at position `i` in `secondNumber`:\n    - For each digit at position `j` in `firstNumber`:\n        - Multiply the digit from `secondNumber` by the digit from `firstNumber` and add previously carried value to the `multiplication` result.  The previously carried value can be found at position `i + j` in the `answer`.\n        - Take the remainder of `multiplication` with `10` to get the ones place digit of the `multiplication` result.\n        - Put the last digit at current position (position `i + j`) in `answer`.\n        - Divide the `multiplication` by `10` to get the new value for carry and add it to `answer` at the next position.  Note, the next position is located at `(i + j + 1)`.\n4. If the last digit in `answer` is zero, before reversing `answer`, we must pop the zero from `answer`. Otherwise, there would be a leading zero in the final answer.\n5. Reverse `answer` and return it.\n\n!?!../Documents/43/slideshow3.json:960,540!?!\n\n#### Implementation\n\n\n<iframe src=\"https://leetcode.com/playground/ktauubWh/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ktauubWh\"></iframe>\n\n\n#### Complexity Analysis\n\nHere $$N$$ and $$M$$ are the number of digits in `num1` and `num2` respectively.\n\n* Time complexity: $$O(M \\cdot N)$$.     \n\n  During multiplication, we perform `N` operations for each of the `M` digits of the second number, so we need $$M \\cdot N$$ time for it.\n\n* Space complexity: $$O(M + N)$$.     \n\n  The space used to store the output is not included in the space complexity. However, because strings are immutable in Python, Java, and Javascript, a temporary data structure, using $$O(M + N)$$ space, is required to store the answer while it is updated.\n  \n  On the other hand, in C++, strings are mutable, so we do not need a temporary data structure to store answer and can update answer directly.  Thus, the C++ approach is a constant space solution."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/multiply-strings/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "44",
        "questionFrontendId": "44",
        "title": "Wildcard Matching",
        "content": "<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code> where:</p>\n\n<ul>\n\t<li><code>&#39;?&#39;</code> Matches any single character.</li>\n\t<li><code>&#39;*&#39;</code> Matches any sequence of characters (including the empty sequence).</li>\n</ul>\n\n<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;a&quot; does not match the entire string &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong>&nbsp;&#39;*&#39; matches any sequence.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cb&quot;, p = &quot;?a&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong>&nbsp;&#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length, p.length &lt;= 2000</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n\t<li><code>p</code> contains only lowercase English letters, <code>&#39;?&#39;</code> or <code>&#39;*&#39;</code>.</li>\n</ul>\n",
        "likes": 9034,
        "dislikes": 410,
        "stats": "{\"totalAccepted\": \"822.8K\", \"totalSubmission\": \"2.6M\", \"totalAcceptedRaw\": 822809, \"totalSubmissionRaw\": 2641685, \"acRate\": \"31.1%\"}",
        "similarQuestions": "[{\"title\": \"Regular Expression Matching\", \"titleSlug\": \"regular-expression-matching\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Substring Matching Pattern\", \"titleSlug\": \"substring-matching-pattern\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Greedy"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/wildcard-matching/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "45",
        "questionFrontendId": "45",
        "title": "Jump Game II",
        "content": "<p>You are given a <strong>0-indexed</strong> array of integers <code>nums</code> of length <code>n</code>. You are initially positioned at&nbsp;index 0.</p>\n\n<p>Each element <code>nums[i]</code> represents the maximum length of a forward jump from index <code>i</code>. In other words, if you are at index <code>i</code>, you can jump to any index <code>(i + j)</code>&nbsp;where:</p>\n\n<ul>\n\t<li><code>0 &lt;= j &lt;= nums[i]</code> and</li>\n\t<li><code>i + j &lt; n</code></li>\n</ul>\n\n<p>Return <em>the minimum number of jumps to reach index </em><code>n - 1</code>. The test cases are generated such that you can reach index&nbsp;<code>n - 1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,1,4]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,0,1,4]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>It&#39;s guaranteed that you can reach <code>nums[n - 1]</code>.</li>\n</ul>\n",
        "likes": 16257,
        "dislikes": 696,
        "stats": "{\"totalAccepted\": \"2M\", \"totalSubmission\": \"4.7M\", \"totalAcceptedRaw\": 2007919, \"totalSubmissionRaw\": 4745221, \"acRate\": \"42.3%\"}",
        "similarQuestions": "[{\"title\": \"Jump Game\", \"titleSlug\": \"jump-game\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Jump Game III\", \"titleSlug\": \"jump-game-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Jump Game VII\", \"titleSlug\": \"jump-game-vii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Jump Game VIII\", \"titleSlug\": \"jump-game-viii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Visited Cells in a Grid\", \"titleSlug\": \"minimum-number-of-visited-cells-in-a-grid\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Jumps to Reach the Last Index\", \"titleSlug\": \"maximum-number-of-jumps-to-reach-the-last-index\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Visit Array Positions to Maximize Score\", \"titleSlug\": \"visit-array-positions-to-maximize-score\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Greedy"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/jump-game-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "46",
        "questionFrontendId": "46",
        "title": "Permutations",
        "content": "<p>Given an array <code>nums</code> of distinct integers, return all the possible <span data-keyword=\"permutation-array\">permutations</span>. You can return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> [[0,1],[1,0]]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 6</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "likes": 20630,
        "dislikes": 379,
        "stats": "{\"totalAccepted\": \"2.9M\", \"totalSubmission\": \"3.6M\", \"totalAcceptedRaw\": 2926961, \"totalSubmissionRaw\": 3592012, \"acRate\": \"81.5%\"}",
        "similarQuestions": "[{\"title\": \"Next Permutation\", \"titleSlug\": \"next-permutation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutations II\", \"titleSlug\": \"permutations-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutation Sequence\", \"titleSlug\": \"permutation-sequence\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Combinations\", \"titleSlug\": \"combinations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/permutations/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "47",
        "questionFrontendId": "47",
        "title": "Permutations II",
        "content": "<p>Given a collection of numbers, <code>nums</code>,&nbsp;that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,2]\n<strong>Output:</strong>\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 8</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n",
        "likes": 9057,
        "dislikes": 161,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 1228679, \"totalSubmissionRaw\": 1957682, \"acRate\": \"62.8%\"}",
        "similarQuestions": "[{\"title\": \"Next Permutation\", \"titleSlug\": \"next-permutation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutations\", \"titleSlug\": \"permutations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Palindrome Permutation II\", \"titleSlug\": \"palindrome-permutation-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Squareful Arrays\", \"titleSlug\": \"number-of-squareful-arrays\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n### Overview\n\nAs the name of the problem suggests, this problem is an extension of the [Permutation](https://leetcode.com/problems/permutations/) problem.\nThe problem is different from the previous permutation problem on the condition that the input array can contain **_duplicates_**.\n\nThe key to solve the problem is still the **_backtracking_** algorithm.\nHowever, we need some adaptation to ensure that the _enumerated_ solutions generated from our backtracking exploration do not have any duplicates.\n\n>As a reminder, **[backtracking](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/)** is a general algorithm for finding all (or some) solutions to some problems with constraints.\nIt incrementally builds candidates to the solutions, and abandons a candidate as soon as it determines that the candidate cannot possibly lead to a solution.\n\nIn this article, we will present a yet another backtracking solution to solve the problem.\n\n---\n### Approach 1: Backtracking with Groups of Numbers\n\n**Intuition**\n\nFirst of all, let us review the general idea of permutation with an example.\n\nGiven the input array `[1, 1, 2]`, to generate a permutation of the array, we could follow the _Depth-First Search_ (DFS) approach, or more precisely the backtracking technique as one will see later.\n\n>The idea is that we pick the numbers one by one. For a permutation of length $$N$$, we would then need $$N$$ stages to generate a valid permutation.\nAt each stage, we need to pick one number into the permutation, out of the remaining available numbers.\nLater at the same stage, we will try out all available choices.\nBy trying out, we progressively build up candidates to the solution, and revert each choice with another alternative until there is no more choice.\n\nLet us walk through the example with paper and pencil, as follows:\n\n- Given the input of `[1, 1, 2]`, at the first stage, we have 2 choices to pick a number as the first number in the final permutation, _i.e._ `1` and `2`.\nSuppose that we pick the number `1`, now the remaining numbers would become `[1, 2]`.\n**Note:** The reason that we have only 2 choices instead of 3, is that there is a duplicate in the given input.\nPicking any of the duplicate numbers as the first number of the permutation would lead us to the same permutation at the end.\nShould the numbers in the array be all unique, we would then have the same number of choices as the length of the array. \n\n- At the second stage, we now then have again 2 choices, _i.e._ `[1, 2]`. \nLet us pick again the number `1`, which leaves us the only remaining number `2`.\n\n- Now at the third stage, we have only one candidate number left, _i.e._ `[2]`. We then pick the last remaining number, which leads to a final permutation sequence of `[1, 1, 2]`.\n\n- Moreover, we need to **_revisit_** each of the above stages, and make a different choice in order to try out all possibilities.\nThe reversion of the choices is what we call __*backtracking*__.\n\nWe illustrate all potential exploration in the following graph where each node represents a choice at a specific stage:\n\n![permutation tree](../Figures/47/47_permutations.png)\n\n>A key insight to avoid generating any **_redundant_** permutation is that at each step rather than viewing each number as a candidate, we consider each **_unique_** number as the true candidate.\nFor instance, at the very beginning, given in the input of `[1, 1, 2]`, we have only two true candidates instead of three.\n\n\n**Algorithm**\n\nGiven the above insight, in order to find out all the unique numbers at each stage, we can build a **_hash table_** (denoted as `counter`), with each unique number as the key and its occurrence as the corresponding value.\n\nTo implement the algorithm, first we define a function called `backtrack(comb, counter)` which generates all permutations, starting from the current combination (`comb`) and the remaining numbers (`counter`).\n\nOnce the function is implemented, it suffices to invoke the function with the initial empty combination and the hash table we built out of the input array, to solve the problem.\n\nHere are some sample implementations.\n\n<iframe src=\"https://leetcode.com/playground/gmT2V4Q3/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"gmT2V4Q3\"></iframe>\n\n**Note:** for a backtracking algorithm, usually there are some explorations that would lead to a *dead end*, and we have to abandon those explorations in the middle.\n\nHowever, due to the specificity of this problem and our exploration strategy, each exploration will result in a valid permutation, _i.e._ none of the efforts is in vain.\nThis insight would prove to be useful in the following complexity analysis.\n\n**Complexity Analysis**\n\nLet $$N$$ be the length of the input array.\nHence, the number of permutations would be at maximum $$N!$$, _i.e._ $$N \\cdot (N-1) \\cdot (N-2) ... 1$$, when each number in the array is unique.\n\n- Time Complexity: $$\\mathcal{O}\\big(\\sum_{k = 1}^{N}{P(N, k)}\\big)$$ where $$P(N, k) = \\frac{N!}{(N - k)!} = N (N - 1) ... (N - k + 1)$$\nis so-called [_k-permutations_of_N_ or _partial permutation_](https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n). \n\n    - As one can see in the exploration graph we have shown earlier, the execution of the backtracking algorithm will unfold itself as a tree, where each node is an invocation of the recursive function `backtrack(comb, counter)`.\n    The total number of steps to complete the exploration is _exactly_ the number of nodes in the tree.\n    Therefore, the time complexity of the algorithm is linked directly with the size of the tree.\n\n    - It now boils down to estimating the number of nodes in the tree.\n    As we know now, each level of the tree corresponds to a specific _stage_ of the exploration.\n    At each stage, the number of candidates to explore is **bounded**.\n    For instance, at the first stage, _at most_ we would have $$N$$ candidates to explore, _i.e._ the number of nodes at this level would be $$N$$.\n    Moving on to the next stage, for each of the nodes in the first stage, we would have $$N-1$$ child nodes. Therefore, the number of nodes at this stage would be $$N \\cdot (N-1)$$.\n    So on and so forwards.\n\n    ![number of nodes](../Figures/47/47_number_of_nodes.png)\n\n    - By summing up all the nodes across the stages, we would then obtain the total number of nodes as $$\\sum_{k = 1}^{N}{P(N, k)}$$ where $$P(N, k) = \\frac{N!}{(N - k)!} = N (N - 1) ... (N - k + 1)$$.\n    As a result, the exact time complexity of the algorithm is $$\\mathcal{O}\\big(\\sum_{k = 1}^{N}{P(N, k)}\\big)$$.\n\n    - The above complexity might appear a bit too abstract to comprehend.\n    Here we could provide another __*loose upper bound*__ on the complexity.\n\n    - It takes $$N$$ steps to generate a single permutation. Since there are in total $$N!$$ possible permutations, at most it would take us $$N \\cdot N!$$ steps to generate all permutations, simply assuming that there is no overlapping effort (which is not true).\n\n\n- Space Complexity: $$\\mathcal{O}(N)$$\n\n    - First of all, we build a hash table out of the input numbers. In the worst case where each number is unique, we would need $$\\mathcal{O}(N)$$ space for the table.\n\n    - Since we applied recursion in the algorithm which consumes some extra space in the function call stack, we would need another $$\\mathcal{O}(N)$$ space for the recursion.\n\n    - During the exploration, we keep a candidate of permutation along the way, which takes yet another $$\\mathcal{O}(N)$$.\n\n    - To sum up, the total space complexity would be $$\\mathcal{O}(N) + \\mathcal{O}(N) + \\mathcal{O}(N) = \\mathcal{O}(N)$$.\n\n    - **Note**, we did not take into account the space needed to hold the results. Otherwise, the space complexity would become $$\\mathcal{O}(N \\cdot N!)$$.\n\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/permutations-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "48",
        "questionFrontendId": "48",
        "title": "Rotate Image",
        "content": "<p>You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).</p>\n\n<p>You have to rotate the image <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg\" style=\"width: 500px; height: 188px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [[7,4,1],[8,5,2],[9,6,3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg\" style=\"width: 500px; height: 201px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n<strong>Output:</strong> [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>\n</ul>\n",
        "likes": 19592,
        "dislikes": 946,
        "stats": "{\"totalAccepted\": \"2.7M\", \"totalSubmission\": \"3.4M\", \"totalAcceptedRaw\": 2654570, \"totalSubmissionRaw\": 3354842, \"acRate\": \"79.1%\"}",
        "similarQuestions": "[{\"title\": \"Determine Whether Matrix Can Be Obtained By Rotation\", \"titleSlug\": \"determine-whether-matrix-can-be-obtained-by-rotation\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Math"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/rotate-image/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "49",
        "questionFrontendId": "49",
        "title": "Group Anagrams",
        "content": "<p>Given an array of strings <code>strs</code>, group the <span data-keyword=\"anagram\">anagrams</span> together. You can return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">strs = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>There is no string in strs that can be rearranged to form <code>&quot;bat&quot;</code>.</li>\n\t<li>The strings <code>&quot;nat&quot;</code> and <code>&quot;tan&quot;</code> are anagrams as they can be rearranged to form each other.</li>\n\t<li>The strings <code>&quot;ate&quot;</code>, <code>&quot;eat&quot;</code>, and <code>&quot;tea&quot;</code> are anagrams as they can be rearranged to form each other.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">strs = [&quot;&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[[&quot;&quot;]]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">strs = [&quot;a&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[[&quot;a&quot;]]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code> consists of lowercase English letters.</li>\n</ul>\n",
        "likes": 21664,
        "dislikes": 742,
        "stats": "{\"totalAccepted\": \"4.4M\", \"totalSubmission\": \"6.1M\", \"totalAcceptedRaw\": 4421748, \"totalSubmissionRaw\": 6143665, \"acRate\": \"72.0%\"}",
        "similarQuestions": "[{\"title\": \"Valid Anagram\", \"titleSlug\": \"valid-anagram\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Group Shifted Strings\", \"titleSlug\": \"group-shifted-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Resultant Array After Removing Anagrams\", \"titleSlug\": \"find-resultant-array-after-removing-anagrams\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Anagrams\", \"titleSlug\": \"count-anagrams\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/group-anagrams/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "50",
        "questionFrontendId": "50",
        "title": "Pow(x, n)",
        "content": "<p>Implement <a href=\"http://www.cplusplus.com/reference/valarray/pow/\" target=\"_blank\">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>x<sup>n</sup></code>).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 2.00000, n = 10\n<strong>Output:</strong> 1024.00000\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 2.10000, n = 3\n<strong>Output:</strong> 9.26100\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 2.00000, n = -2\n<strong>Output:</strong> 0.25000\n<strong>Explanation:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-100.0 &lt; x &lt; 100.0</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup>-1</code></li>\n\t<li><code>n</code> is an integer.</li>\n\t<li>Either <code>x</code> is not zero or <code>n &gt; 0</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sup>n</sup> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 11430,
        "dislikes": 10479,
        "stats": "{\"totalAccepted\": \"2.6M\", \"totalSubmission\": \"6.7M\", \"totalAcceptedRaw\": 2556117, \"totalSubmissionRaw\": 6715414, \"acRate\": \"38.1%\"}",
        "similarQuestions": "[{\"title\": \"Sqrt(x)\", \"titleSlug\": \"sqrtx\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Super Pow\", \"titleSlug\": \"super-pow\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Collisions of Monkeys on a Polygon\", \"titleSlug\": \"count-collisions-of-monkeys-on-a-polygon\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/powx-n/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "51",
        "questionFrontendId": "51",
        "title": "N-Queens",
        "content": "<p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p>\n\n<p>Given an integer <code>n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>Each solution contains a distinct board configuration of the n-queens&#39; placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space, respectively.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" style=\"width: 600px; height: 268px;\" />\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> [[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]\n<strong>Explanation:</strong> There exist two distinct solutions to the 4-queens puzzle as shown above\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [[&quot;Q&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n</ul>\n",
        "likes": 14049,
        "dislikes": 341,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 1179340, \"totalSubmissionRaw\": 1579445, \"acRate\": \"74.7%\"}",
        "similarQuestions": "[{\"title\": \"N-Queens II\", \"titleSlug\": \"n-queens-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Grid Illumination\", \"titleSlug\": \"grid-illumination\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/n-queens/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "52",
        "questionFrontendId": "52",
        "title": "N-Queens II",
        "content": "<p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p>\n\n<p>Given an integer <code>n</code>, return <em>the number of distinct solutions to the&nbsp;<strong>n-queens puzzle</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" style=\"width: 600px; height: 268px;\" />\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two distinct solutions to the 4-queens puzzle as shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n</ul>\n",
        "likes": 4228,
        "dislikes": 282,
        "stats": "{\"totalAccepted\": \"564.2K\", \"totalSubmission\": \"723.9K\", \"totalAcceptedRaw\": 564244, \"totalSubmissionRaw\": 723884, \"acRate\": \"77.9%\"}",
        "similarQuestions": "[{\"title\": \"N-Queens\", \"titleSlug\": \"n-queens\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/n-queens-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "53",
        "questionFrontendId": "53",
        "title": "Maximum Subarray",
        "content": "<p>Given an integer array <code>nums</code>, find the <span data-keyword=\"subarray-nonempty\">subarray</span> with the largest sum, and return <em>its sum</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The subarray [4,-1,2,1] has the largest sum 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The subarray [1] has the largest sum 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,4,-1,7,8]\n<strong>Output:</strong> 23\n<strong>Explanation:</strong> The subarray [5,4,-1,7,8] has the largest sum 23.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.</p>\n",
        "likes": 37254,
        "dislikes": 1580,
        "stats": "{\"totalAccepted\": \"5.7M\", \"totalSubmission\": \"10.8M\", \"totalAcceptedRaw\": 5727963, \"totalSubmissionRaw\": 10844465, \"acRate\": \"52.8%\"}",
        "similarQuestions": "[{\"title\": \"Best Time to Buy and Sell Stock\", \"titleSlug\": \"best-time-to-buy-and-sell-stock\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Maximum Product Subarray\", \"titleSlug\": \"maximum-product-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Degree of an Array\", \"titleSlug\": \"degree-of-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Longest Turbulent Subarray\", \"titleSlug\": \"longest-turbulent-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Score Of Spliced Array\", \"titleSlug\": \"maximum-score-of-spliced-array\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Absolute Sum of Any Subarray\", \"titleSlug\": \"maximum-absolute-sum-of-any-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Subarray Sum After One Operation\", \"titleSlug\": \"maximum-subarray-sum-after-one-operation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Substring With Largest Variance\", \"titleSlug\": \"substring-with-largest-variance\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Subarrays With Score Less Than K\", \"titleSlug\": \"count-subarrays-with-score-less-than-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Value of a String in an Array\", \"titleSlug\": \"maximum-value-of-a-string-in-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Substring With Maximum Cost\", \"titleSlug\": \"find-the-substring-with-maximum-cost\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"K Items With the Maximum Sum\", \"titleSlug\": \"k-items-with-the-maximum-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Maximum Good Subarray Sum\", \"titleSlug\": \"maximum-good-subarray-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximize Subarray Sum After Removing All Occurrences of One Element\", \"titleSlug\": \"maximize-subarray-sum-after-removing-all-occurrences-of-one-element\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Divide and Conquer"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/maximum-subarray/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "54",
        "questionFrontendId": "54",
        "title": "Spiral Matrix",
        "content": "<p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>Output:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n",
        "likes": 17084,
        "dislikes": 1535,
        "stats": "{\"totalAccepted\": \"2.2M\", \"totalSubmission\": \"4M\", \"totalAcceptedRaw\": 2239969, \"totalSubmissionRaw\": 4013746, \"acRate\": \"55.8%\"}",
        "similarQuestions": "[{\"title\": \"Spiral Matrix II\", \"titleSlug\": \"spiral-matrix-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Spiral Matrix III\", \"titleSlug\": \"spiral-matrix-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Spiral Matrix IV\", \"titleSlug\": \"spiral-matrix-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Well for some problems, the best way really is to come up with some algorithms for simulation. Basically, you need to simulate what the problem asks us to do.",
          "We go boundary by boundary and move inwards. That is the essential operation. First row, last column, last row, first column, and then we move inwards by 1 and repeat. That's all. That is all the simulation that we need.",
          "Think about when you want to switch the progress on one of the indexes. If you progress on i out of [i, j], you'll shift in the same column. Similarly, by changing values for j, you'd be shifting in the same row.\r\nAlso, keep track of the end of a boundary so that you can move inwards and then keep repeating. It's always best to simulate edge cases like a single column or a single row to see if anything breaks or not."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Matrix"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/spiral-matrix/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "55",
        "questionFrontendId": "55",
        "title": "Jump Game",
        "content": "<p>You are given an integer array <code>nums</code>. You are initially positioned at the array&#39;s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p>\n\n<p>Return <code>true</code><em> if you can reach the last index, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,1,4]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1,0,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 21444,
        "dislikes": 1470,
        "stats": "{\"totalAccepted\": \"3M\", \"totalSubmission\": \"7.5M\", \"totalAcceptedRaw\": 3007298, \"totalSubmissionRaw\": 7458887, \"acRate\": \"40.3%\"}",
        "similarQuestions": "[{\"title\": \"Jump Game II\", \"titleSlug\": \"jump-game-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Jump Game III\", \"titleSlug\": \"jump-game-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Jump Game VII\", \"titleSlug\": \"jump-game-vii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Jump Game VIII\", \"titleSlug\": \"jump-game-viii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Number of Visited Cells in a Grid\", \"titleSlug\": \"minimum-number-of-visited-cells-in-a-grid\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Largest Element in an Array after Merge Operations\", \"titleSlug\": \"largest-element-in-an-array-after-merge-operations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Greedy"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/jump-game/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "56",
        "questionFrontendId": "56",
        "title": "Merge Intervals",
        "content": "<p>Given an array&nbsp;of <code>intervals</code>&nbsp;where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[2,6],[8,10],[15,18]]\n<strong>Output:</strong> [[1,6],[8,10],[15,18]]\n<strong>Explanation:</strong> Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,4],[4,5]]\n<strong>Output:</strong> [[1,5]]\n<strong>Explanation:</strong> Intervals [1,4] and [4,5] are considered overlapping.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[4,7],[1,4]]\n<strong>Output:</strong> [[1,7]]\n<strong>Explanation:</strong> Intervals [1,4] and [4,7] are considered overlapping.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 24294,
        "dislikes": 893,
        "stats": "{\"totalAccepted\": \"3.7M\", \"totalSubmission\": \"7.3M\", \"totalAcceptedRaw\": 3731847, \"totalSubmissionRaw\": 7337339, \"acRate\": \"50.9%\"}",
        "similarQuestions": "[{\"title\": \"Insert Interval\", \"titleSlug\": \"insert-interval\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Meeting Rooms\", \"titleSlug\": \"meeting-rooms\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Meeting Rooms II\", \"titleSlug\": \"meeting-rooms-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Teemo Attacking\", \"titleSlug\": \"teemo-attacking\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add Bold Tag in String\", \"titleSlug\": \"add-bold-tag-in-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Range Module\", \"titleSlug\": \"range-module\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Employee Free Time\", \"titleSlug\": \"employee-free-time\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Partition Labels\", \"titleSlug\": \"partition-labels\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Interval List Intersections\", \"titleSlug\": \"interval-list-intersections\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Amount of New Area Painted Each Day\", \"titleSlug\": \"amount-of-new-area-painted-each-day\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Substring of One Repeating Character\", \"titleSlug\": \"longest-substring-of-one-repeating-character\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Integers in Intervals\", \"titleSlug\": \"count-integers-in-intervals\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Divide Intervals Into Minimum Number of Groups\", \"titleSlug\": \"divide-intervals-into-minimum-number-of-groups\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Determine if Two Events Have Conflict\", \"titleSlug\": \"determine-if-two-events-have-conflict\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Ways to Group Overlapping Ranges\", \"titleSlug\": \"count-ways-to-group-overlapping-ranges\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Points That Intersect With Cars\", \"titleSlug\": \"points-that-intersect-with-cars\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Count Days Without Meetings\", \"titleSlug\": \"count-days-without-meetings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimize Connected Groups by Inserting Interval\", \"titleSlug\": \"minimize-connected-groups-by-inserting-interval\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n---\n\n<div>\n    <div class=\"video-container\">\n        <iframe src=\"https://player.vimeo.com/video/471861267\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n    </div>\n</div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Connected Components\n\n**Intuition**\n\nIf we draw a graph (with intervals as nodes) that contains undirected edges between all pairs of intervals that overlap, then all intervals in each *connected component* of the graph can be merged into a single interval.\n\n**Algorithm**\n\nWith the above intuition in mind, we can represent the graph as an adjacency list, inserting directed edges in both directions to simulate undirected edges. Then, to determine which connected component each node is in, we perform graph traversals from arbitrary unvisited nodes until all nodes have been visited. To do this efficiently, we store visited nodes in a `Set`, allowing for constant time containment checks and insertion. Finally, we consider each connected component, merging all of its intervals by constructing a new `Interval` with `start` equal to the minimum start among them and `end` equal to the maximum end.\n\nThis algorithm is correct simply because it is basically the brute force solution. We compare every interval to every other interval, so we know exactly which intervals overlap. The reason for the connected component search is that two intervals may not directly overlap, but might overlap indirectly via a third interval. See the example below to see this more clearly.\n\n![Components Example](../Figures/56/component.png)\n\nAlthough (1, 5) and (6, 10) do not directly overlap, either would overlap with the other if first merged with (4, 7). There are two connected components, so if we merge their nodes, we expect to get the following two merged intervals:\n\n(1, 10), (15, 20)\n\n\n<iframe src=\"https://leetcode.com/playground/VH5daGtY/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"VH5daGtY\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n^2)$$\n\n    Building the graph costs $$O(V + E) = O(V) + O(E) = O(n) + O(n^2) = O(n^2)$$ time, as in the worst case all intervals are mutually overlapping. Traversing the graph has the same cost (although it might appear higher at first) because our `visited` set guarantees that each node will be visited exactly once. Finally, because each node is part of exactly one component, the merge step costs $$O(V) = O(n)$$ time. This all adds up as follows:\n\n    $$\n        O(n^2) + O(n^2) + O(n) = O(n^2)\n    $$\n\n* Space complexity : $$O(n^2)$$\n\n    As previously mentioned, in the worst case, all intervals are mutually overlapping, so there will be an edge for every pair of intervals. Therefore, the memory footprint is quadratic in the input size.\n\n<br/>\n\n---\n\n### Approach 2: Sorting\n\n**Intuition**\n\nIf we sort the intervals by their `start` value, then each set of intervals that can be merged will appear as a contiguous \"run\" in the sorted list.\n\n**Algorithm**\n\nFirst, we sort the list as described. Then, we insert the first interval into our `merged` list and continue considering each interval in turn as follows: If the current interval begins *after* the previous interval ends, then they do not overlap and we can append the current interval to `merged`. Otherwise, they do overlap, and we merge them by updating the `end` of the previous interval if it is less than the `end` of the current interval.\n\nA simple proof by contradiction shows that this algorithm always produces the correct answer. First, suppose that the algorithm at some point fails to merge two intervals that should be merged. This would imply that there exists some triple of indices $$i$$, $$j$$, and $$k$$ in a list of intervals $$\\text{ints}$$ such that $$i < j < k$$ and ($$\\text{ints[i]}$$, $$\\text{ints[k]}$$) can be merged, but neither ($$\\text{ints[i]}$$, $$\\text{ints[j]}$$) nor ($$\\text{ints[j]}$$, $$\\text{ints[k]}$$) can be merged. From this scenario follow several inequalities:\n\n$$\n\\begin{aligned}\n    \\text{ints[i].end} < \\text{ints[j].start} \\\\\n    \\text{ints[j].end} < \\text{ints[k].start} \\\\\n    \\text{ints[i].end} \\geq \\text{ints[k].start} \\\\\n\\end{aligned}\n$$\n\nWe can chain these inequalities (along with the following inequality, implied by the well-formedness of the intervals: $$\\text{ints[j].start} \\leq \\text{ints[j].end}$$) to demonstrate a contradiction:\n\n$$\n\\begin{aligned}\n    \\text{ints[i].end} < \\text{ints[j].start} \\leq \\text{ints[j].end} < \\text{ints[k].start} \\\\\n    \\text{ints[i].end} \\geq \\text{ints[k].start}\n\\end{aligned}\n$$\n\nTherefore, all mergeable intervals must occur in a contiguous run of the sorted list.\n\n![Sorting Example](../Figures/56/sort.png)\n\n\nConsider the example above, where the intervals are sorted, and then all mergeable intervals form contiguous blocks.\n\n<iframe src=\"https://leetcode.com/playground/95HUcjnF/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"95HUcjnF\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n\\log{}n)$$\n\n    Other than the `sort` invocation, we do a simple linear scan of the list, so the runtime is dominated by the $$O(n\\log{}n)$$ complexity of sorting.\n\n* Space complexity : $$O(\\log N)$$ (or $$O(n)$$)\n\n    If we can sort `intervals` in place, we do not need more than constant additional space, although the sorting itself takes $$O(\\log n)$$ space. Otherwise, we must allocate linear space to store a copy of `intervals` and sort that."
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/merge-intervals/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "57",
        "questionFrontendId": "57",
        "title": "Insert Interval",
        "content": "<p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and <code>intervals</code> is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.</p>\n\n<p>Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>start<sub>i</sub></code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</p>\n\n<p>Return <code>intervals</code><em> after the insertion</em>.</p>\n\n<p><strong>Note</strong> that you don&#39;t need to modify <code>intervals</code> in-place. You can make a new array and return it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>Output:</strong> [[1,5],[6,9]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n<strong>Output:</strong> [[1,2],[3,10],[12,16]]\n<strong>Explanation:</strong> Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals</code> is sorted by <code>start<sub>i</sub></code> in <strong>ascending</strong> order.</li>\n\t<li><code>newInterval.length == 2</code></li>\n\t<li><code>0 &lt;= start &lt;= end &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "likes": 11658,
        "dislikes": 908,
        "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"3.7M\", \"totalAcceptedRaw\": 1668279, \"totalSubmissionRaw\": 3743881, \"acRate\": \"44.6%\"}",
        "similarQuestions": "[{\"title\": \"Merge Intervals\", \"titleSlug\": \"merge-intervals\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Range Module\", \"titleSlug\": \"range-module\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Integers in Intervals\", \"titleSlug\": \"count-integers-in-intervals\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Intervals Array is sorted. Can you use Binary Search to find the correct position to insert the new Interval.?",
          "Can you try merging the overlapping intervals while inserting the new interval?",
          "This can be done by comparing the end of the last interval with the start of the new interval and vice versa."
        ],
        "topicTags": [
          {
            "name": "Array"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe are given a sorted list of non-overlapping `intervals` and a `newInterval`. The task is to insert the `newInterval` into the `intervals` while maintaining sorted order and ensuring no overlapping intervals. If there is any overlap, the overlapping intervals should be merged. In the end, return the intervals list with the addition of the new intervals.\n\nTwo key observations are crucial for this problem:\n1. The given intervals are already sorted in ascending order based on the start values.\n2. Initially, the intervals are non-overlapping, but inserting a new interval might lead to overlaps that need resolution by merging while maintaining sorted order.\n\nTo solve this problem, we break it into three cases when comparing the current interval with the new interval:\nCase 1. The current interval ends before the new interval starts.\nCase 2. There is an overlap, and the intervals need merging.\nCase 3. The current interval starts after the new interval ends.\n\nA visual representation below illustrates all three scenarios:\n\n![img](../Figures/57_re/1.png)\n\n\nNow let us consider the given problem description example with `intervals` and a `newInterval`:\n```\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\n```\n\nThe first interval starts at 1 and ends at 3, while the second interval starts at 6 and ends at 9. The goal is to insert the `newInterval` into the existing list of `intervals`, maintaining sorted order.\n\nUpon analysis, we observe that the `newInterval` [2, 5] overlaps with the first interval [1, 3] because 2 is less than 3. Now, since we know the intervals need to be merged, we must ensure the merged interval covers the entire overlapping region.\n\nTo achieve this, we take the maximum of the end of the first interval and the end of the new interval, as well as the minimum of the start of the first interval and the start of the new interval. Therefore, the merged interval becomes `[min(1, 2), max(3, 5)] = [1, 5]`.\n\nMoving on to the second interval [6, 9], its starting point (6) comes after the new interval's ending point (5). There is no overlap between them. Therefore, the second interval remains unchanged.\n\n\n| Original Intervals | New Interval | Action                     | Resulting Intervals |\n|-------------------- |--------------|---------------------------- |----------------------|\n|      [1,3]          |   [2,5]      | New interval overlaps with the first interval [1,3]. Merge intervals by taking [min(1, 2), max(3, 5)] = [1, 5]. |      [1,5]           |\n|      [6,9]          |              | No overlap with the new interval [2,5]. Interval remains unchanged. |      [6,9]           |\n\nIn conclusion, the final result is [[1, 5], [6, 9]], representing the intervals after inserting and merging the new interval [2, 5].\n\nIn a concrete business context, this problem may be presented as follows: Suppose we have an array representing video watch times, where each segment consists of the start and stop times of a user watching a video. The task is to calculate the total number of unique minutes watched across all the video segments. This is fundamentally the same question.\n\n> We recommend solving [Merge Intervals](https://leetcode.com/problems/merge-intervals/) problem before attempting this question, as it provides valuable insights into pattern recognition. This question is an extension of the Merge Intervals concept, building upon the same principles.\n\n---\n\n### Approach 1: Linear Search\n\n#### Intuition\n\nWe can do a linear search by iterating through all the intervals and checking which one of the three conditions the intervals fall under:\n\n1. **No Overlaps before Merging:**\n   - This occurs when the current interval ends before the new interval starts.\n\n2. **Overlapping and Merging:**\n   - This occurs when the starting point of the current interval is less than or equal to the ending point of the new interval (`newInterval[1]`), indicating an overlap. We can merge the current interval with the new interval by updating the start and end values of the new interval.\n\n3. **No Overlapping after Merging:**\n   - This occurs when the current interval starts after the new interval ends.\n\n##### 1. Identifying Non-Overlapping Intervals Before Merging:\nWe iterate through all intervals, checking whether the endpoint of the current interval (`intervals[i][1]`) is less than the starting point of the new interval (`newInterval[0]`). If this condition holds true, it indicates there is no overlap before merging, and we add the current interval to the result.\n\n##### 2. Identifying and Merging Overlapping Intervals:\nDuring the iteration, we identify overlap by comparing the endpoint of the new interval (`newInterval[1]`) with the starting point of the current interval (`intervals[i][0]`). When an overlap is detected, we merge the intervals by updating the start and end values of the new interval. The index (`i`) is then incremented to move to the next interval. After merging, the new interval is added to the result.\n\n##### 3. Identifying Non-Overlapping Intervals After Merging:\nAs we have already added the non-overlapping intervals before `newInterval` and merged overlapping ones, the remaining intervals after are guaranteed not to overlap with the newly merged interval. We simply add these remaining intervals to the result.\n\nThe following slideshow illustrates how the linear search algorithm is employed:\n\n!?!../Documents/57/57_LS.json:945,480!?!\n\n#### Algorithm\n\n- Initialize variables `n` and `i` to store the size of intervals and the current index, respectively, and an empty array `res` to store the result.\n- Case 1: No Overlap Before Insertion:\n    - Loop through intervals while `i` is less than `n` and the current interval's endpoint (`intervals[i][1]`) is less than the new interval's start point (`newInterval[0]`).\n    - Add the current interval from intervals to the `res` array.\n    - Increment `i` to move to the next interval.\n- Case 2: Overlap and Merge:\n    - Loop through intervals while `i` is less than `n` and the new interval's endpoint (`newInterval[1]`) is greater than or equal to the current interval's start point (`intervals[i][0]`).\n    - Update the newInterval's start point to the minimum of its current start and the current interval's start.\n    - Update the newInterval's endpoint to the maximum of its current end and the current interval's end.\n    - This essentially merges overlapping intervals into a single larger interval.\n    - Increment `i` to move to the next interval.\n- Add the updated `newInterval` to the `res` array, representing the merged interval.\n- Case 3: No overlap after insertion:\n    - Loop through the remaining intervals (from index `i`) and add them to the `res` array.\n        - This includes intervals that occur after the new interval and those that don't overlap, as they have already been correctly inserted in the previous iterations (previous two cases).\n- Return the `res` array containing all intervals with the new interval inserted correctly.\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/XFeK8AcX/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"XFeK8AcX\"></iframe>\n\n#### Complexity Analysis\n\nLet $N$ be the number of intervals.\n\n* Time complexity: $O(N)$\n\n    We iterate through the intervals once, and each interval is considered and processed only once.\n\n* Space complexity: $O(1)$\n\n    We only use the result (`res`) array to store output, so this could be considered $O(1)$.\n\n---\n\n### Approach 2: Binary Search\n\n#### Intuition\n\nTo apply binary search to a problem, a crucial requirement is that the input should have a monotonically increasing or decreasing nature. In our given scenario, it is explicitly stated that the input is already sorted with respect to the start value, indicating a monotonically increasing order. Therefore, we can confidently consider applying binary search.\n\n##### 1. Finding the Insertion Position\nAs the intervals are sorted by start value, we perform a binary search comparing the starting point of the current interval (`intervals[mid][0]`) with the starting point of the new interval (`target`). If `intervals[mid][0]` is less than the target, it indicates that the insertion point should be to the right of the current position. Consequently, we update `left` to `mid + 1`. If it's greater, the insertion point should be to the left, so we update `right` to `mid - 1`. This process continues until `left` becomes greater than `right`, revealing the correct insertion position.\n\n##### 2. Handling Merging\n1. If `res` is empty or the end of the last interval in `res` is less than the starting point of the current interval, it indicates there is no overlap before merging. The current interval is directly added to `res` in such cases.\n2. If an overlap is detected, signifying the need for merging, the current interval is merged with the last interval in `res`. The end of the last interval in `res` is updated to the maximum of its current end and the end of the current interval.\n\nThe following slideshow illustrates how the binary search algorithm is employed:\n\n!?!../Documents/57/57_BS.json:930,315!?!\n\n#### Algorithm\n\n- If `intervals` is empty, it means there are no existing intervals, so we can simply return a array containing the `newInterval`.\n- Perform a binary search to find the correct position to insert the new interval in the `intervals` array. It updates the values of `left` and `right` based on the comparison of the target value with the first element of the interval at the middle index.\n    - Initialize the variables `target` with the starting point of `newInterval` (i.e., `newInterval[0]`), `left` with 0, and `right` with `n - 1` to define the search space in the `intervals` array.\n    - Perform a binary search by repeatedly dividing the search space in half until `left` is greater than `right`.\n    - Calculate the middle index `mid` as the average of `left` and `right`.\n    - If the start of the interval at index `mid` is less than the target value, update `left` to `mid + 1` to search the right half of the search space. Otherwise, update `right` to `mid - 1` to search the left half of the search space.\n    - The search updates `left` and `right` until they converge to the correct position. Repeat until `left` is greater than `right`.\n- Use `intervals.insert(intervals.begin() + left, newInterval)` to insert the `newInterval` at the correct position.\n- Initialize an empty array `res` to store the result.\n- Iterate through the sorted intervals.\n    - Check if `res` is empty or if the end of the last interval in `res` is less than the start of the current interval. If either condition is true, add the current interval to `res`.\n    - If there is an overlap, update the endpoint of the last interval in `res` to cover the current interval. This step ensures that non-overlapping intervals are added directly, and overlapping intervals are merged.\n- The final merged and inserted intervals are stored in the `res` array, which is then returned.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/Rg6hYgzg/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Rg6hYgzg\"></iframe>\n\n#### Complexity Analysis\n\nLet $N$ be the number of intervals.\n\n* Time complexity: $O(N)$\n\n    The binary search for finding the position to insert the `newInterval` has a time complexity of $O(\\log N)$. However, the insertion of the `newInterval` into the list may take $O(N)$ time in the worst case, as it could involve shifting elements within the list. Consequently, the overall time complexity is $O(N + \\log N)$, which simplifies to $O(N)$.\n\n* Space complexity: $O(N)$\n\n    We use the additional space to store the result (`res`) and perform calculations using `res,` so it does count towards the space complexity. In the worst case, the size of `res` will be proportional to the number of intervals in the input list."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/insert-interval/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "58",
        "questionFrontendId": "58",
        "title": "Length of Last Word",
        "content": "<p>Given a string <code>s</code> consisting of words and spaces, return <em>the length of the <strong>last</strong> word in the string.</em></p>\n\n<p>A <strong>word</strong> is a maximal <span data-keyword=\"substring-nonempty\">substring</span> consisting of non-space characters only.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Hello World&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The last word is &quot;World&quot; with length 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;   fly me   to   the moon  &quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The last word is &quot;moon&quot; with length 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;luffy is still joyboy&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The last word is &quot;joyboy&quot; with length 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of only English letters and spaces <code>&#39; &#39;</code>.</li>\n\t<li>There will be at least one word in <code>s</code>.</li>\n</ul>\n",
        "likes": 6241,
        "dislikes": 350,
        "stats": "{\"totalAccepted\": \"3.2M\", \"totalSubmission\": \"5.5M\", \"totalAcceptedRaw\": 3198307, \"totalSubmissionRaw\": 5516719, \"acRate\": \"58.0%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/length-of-last-word/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "59",
        "questionFrontendId": "59",
        "title": "Spiral Matrix II",
        "content": "<p>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n<sup>2</sup></code> in spiral order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> [[1,2,3],[8,9,4],[7,6,5]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n",
        "likes": 6848,
        "dislikes": 283,
        "stats": "{\"totalAccepted\": \"766.7K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 766688, \"totalSubmissionRaw\": 1029607, \"acRate\": \"74.5%\"}",
        "similarQuestions": "[{\"title\": \"Spiral Matrix\", \"titleSlug\": \"spiral-matrix\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Spiral Matrix III\", \"titleSlug\": \"spiral-matrix-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Spiral Matrix IV\", \"titleSlug\": \"spiral-matrix-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Matrix"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n### Overview\n\nThere are various problems in spiral matrix series with some variations like [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/) and [Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/).\n\nIn order to solve such questions, the core idea is to decode the underlying pattern. This can be done by simulating the pattern and finding a generic representation that would work for any given $$n$$.\nLet's discuss a few approaches.\n\n---\n### Approach 1: Traverse Layer by Layer in Spiral Form\n\n**Intuition**\n\nIf we try to build a pattern for a given $$n$$, we observe that the pattern repeats after completing one circular traversal around the matrix. Let's call this one circular traversal as  _layer_. We start traversing from the outer layer and move towards inner layers on every iteration.\n\n![img](../Figures/59/spiral_layers.png)\n\n**Algorithm**\n\nLet's devise an algorithm for the spiral traversal:\n\n-  We can observe that, for any given $$n$$, the total number of layers is given by :\n$$\\lfloor \\frac{n+1}{2} \\rfloor$$\nThis works for both even and odd $$n$$.\n\n_Example_\n\nFor $$n = 3$$, $$layers = 2$$\n\nFor $$n = 6$$, total $$layers = 3$$\n\n- Also, for each layer, we traverse in _at most_ 4 directions :\n\n\n![img](../Figures/59/spiral_traverse.png)\n\n\nIn every direction, either row or column remains constant and other parameter changes (increments/decrements).\n\n_Direction 1: From top left corner to top right corner._\n\nThe row remains constant as $$\\text{layer}$$ and column increments from $$\\text{layer}$$ to  $$n-\\text{layer}-1$$\n\n_Direction 2: From top right corner to the bottom right corner._\n\nThe column remains constant as $$n-layer-1$$ and row increments from\n$$\\text{layer}+1$$ to $$n-\\text{layer}$$.\n\n_Direction 3: From bottom right corner to bottom left corner._\n\nThe row remains constant as $$n-\\text{layer}-1$$ and column decrements from $$n-\\text{layer}-2$$ to $$\\text{layer}$$.\n\n_Direction 4: From bottom left corner to top left corner._\n\nThe column remains constant as $$\\text{layer}$$ and column decrements from $$n-\\text{layer}-2$$ to $$\\text{layer}+1$$.\n\nThis process repeats $$(n+1)/2$$ times until all layers are traversed.\n\n![img](../Figures/59/spiral_detailed_fix.png)\n\n\n<iframe src=\"https://leetcode.com/playground/fs3Ga77r/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"fs3Ga77r\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$\\mathcal{O}(n^2)$$. Here, $$n$$ is given input and we are iterating over $$n\\cdot n$$ matrix in spiral form.\n* Space Complexity: $$\\mathcal{O}(1)$$  We use constant extra space for storing $$cnt$$.\n\n---\n### Approach 2: Optimized spiral traversal\n\n**Intuition**\n\nOur main aim is to walk in a spiral form and fill the array in a particular pattern. In the previous approach, we used a separate loop for each direction. Here, we discuss another optimized to achieve the same result.\n\n**Algorithm**\n\n- We have to walk in 4 directions forming a layer. We use an array $$dir$$ that stores the changes in $$x$$ and $$y$$ co-ordinates in each direction.\n\n_Example_\n\nIn left to right walk ( _direction #1_ ), $$x$$ co-ordinates remains same and $$y$$ increments ($$x = 0$$, $$y = 1$$).\n\nIn right to left walk ( _direction #3_ ), $$x$$ remains same and $$y$$ decrements ($$x = 0$$, $$y = -1$$).\n\nUsing this intuition, we pre-define an array $$dir$$ having $$x$$ and $$y$$ co-ordinate changes for each direction. There are a total of 4 directions as discussed in the previous approach.\n\n- The $$\\text{row}$$ and $$col$$ variables represent the current $$x$$ and $$y$$ co-ordinates respectively. It updates based on the direction in which we are moving.\n\n_How do we know when we have to change the direction?_\n\nWhen we find the next row or column in a particular direction has a non-zero value, we are sure it is already traversed and we change the direction.\n\nLet $$d$$ be the current direction index. We go to next direction in array $$dir$$ using $$(d+ 1) \\% 4$$. Using this we could go back to direction 1 after completing one circular traversal from direction 1 to direction 4 .\n\n> It must be noted that we use `floorMod` in Java instead of modulo $$\\%$$ to handle mod of negative numbers. This is required because row and column values might go negative and using $$\\%$$ won't give desired results in such cases.  \n\n<iframe src=\"https://leetcode.com/playground/97g6k8bX/shared\" frameBorder=\"0\" width=\"100%\" height=\"480\" name=\"97g6k8bX\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$\\mathcal{O}(n^2)$$. Here, $$n$$ is given input and we are iterating over $$n\\cdot n$$ matrix in spiral form.\n* Space Complexity: $$\\mathcal{O}(1)$$  We use constant extra space for storing $$cnt$$."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/spiral-matrix-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "60",
        "questionFrontendId": "60",
        "title": "Permutation Sequence",
        "content": "<p>The set <code>[1, 2, 3, ...,&nbsp;n]</code> contains a total of <code>n!</code> unique permutations.</p>\n\n<p>By listing and labeling all of the permutations in order, we get the following sequence for <code>n = 3</code>:</p>\n\n<ol>\n\t<li><code>&quot;123&quot;</code></li>\n\t<li><code>&quot;132&quot;</code></li>\n\t<li><code>&quot;213&quot;</code></li>\n\t<li><code>&quot;231&quot;</code></li>\n\t<li><code>&quot;312&quot;</code></li>\n\t<li><code>&quot;321&quot;</code></li>\n</ol>\n\n<p>Given <code>n</code> and <code>k</code>, return the <code>k<sup>th</sup></code> permutation sequence.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 3, k = 3\n<strong>Output:</strong> \"213\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 4, k = 9\n<strong>Output:</strong> \"2314\"\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> n = 3, k = 1\n<strong>Output:</strong> \"123\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n\t<li><code>1 &lt;= k &lt;= n!</code></li>\n</ul>\n",
        "likes": 7178,
        "dislikes": 502,
        "stats": "{\"totalAccepted\": \"541.3K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 541254, \"totalSubmissionRaw\": 1045204, \"acRate\": \"51.8%\"}",
        "similarQuestions": "[{\"title\": \"Next Permutation\", \"titleSlug\": \"next-permutation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutations\", \"titleSlug\": \"permutations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Recursion"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/permutation-sequence/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "61",
        "questionFrontendId": "61",
        "title": "Rotate List",
        "content": "<p>Given the <code>head</code> of a linked&nbsp;list, rotate the list to the right by <code>k</code> places.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg\" style=\"width: 450px; height: 191px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], k = 2\n<strong>Output:</strong> [4,5,1,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg\" style=\"width: 305px; height: 350px;\" />\n<pre>\n<strong>Input:</strong> head = [0,1,2], k = 4\n<strong>Output:</strong> [2,0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 500]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt;= 2 * 10<sup>9</sup></code></li>\n</ul>\n",
        "likes": 11059,
        "dislikes": 1538,
        "stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"3.7M\", \"totalAcceptedRaw\": 1502560, \"totalSubmissionRaw\": 3666482, \"acRate\": \"41.0%\"}",
        "similarQuestions": "[{\"title\": \"Rotate Array\", \"titleSlug\": \"rotate-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Split Linked List in Parts\", \"titleSlug\": \"split-linked-list-in-parts\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/rotate-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "62",
        "questionFrontendId": "62",
        "title": "Unique Paths",
        "content": "<p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>\n\n<p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>\n\n<p>The test cases are generated so that the answer will be less than or equal to <code>2 * 10<sup>9</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\" style=\"width: 400px; height: 183px;\" />\n<pre>\n<strong>Input:</strong> m = 3, n = 7\n<strong>Output:</strong> 28\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> m = 3, n = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right\n3. Down -&gt; Right -&gt; Down\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n</ul>\n",
        "likes": 18159,
        "dislikes": 491,
        "stats": "{\"totalAccepted\": \"2.7M\", \"totalSubmission\": \"4M\", \"totalAcceptedRaw\": 2671582, \"totalSubmissionRaw\": 4020912, \"acRate\": \"66.4%\"}",
        "similarQuestions": "[{\"title\": \"Unique Paths II\", \"titleSlug\": \"unique-paths-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Path Sum\", \"titleSlug\": \"minimum-path-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Dungeon Game\", \"titleSlug\": \"dungeon-game\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Path Cost in a Grid\", \"titleSlug\": \"minimum-path-cost-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Cost Homecoming of a Robot in a Grid\", \"titleSlug\": \"minimum-cost-homecoming-of-a-robot-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Ways to Reach a Position After Exactly k Steps\", \"titleSlug\": \"number-of-ways-to-reach-a-position-after-exactly-k-steps\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paths in Matrix Whose Sum Is Divisible by K\", \"titleSlug\": \"paths-in-matrix-whose-sum-is-divisible-by-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Combinatorics"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/unique-paths/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "63",
        "questionFrontendId": "63",
        "title": "Unique Paths II",
        "content": "<p>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <b>top-left corner</b> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>\n\n<p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include <strong>any</strong> square that is an obstacle.</p>\n\n<p>Return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>\n\n<p>The testcases are generated so that the answer will be less than or equal to <code>2 * 10<sup>9</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -&gt; Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right -&gt; Right\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> obstacleGrid = [[0,1],[0,0]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == obstacleGrid.length</code></li>\n\t<li><code>n == obstacleGrid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n</ul>\n",
        "likes": 9585,
        "dislikes": 555,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"3.2M\", \"totalAcceptedRaw\": 1400036, \"totalSubmissionRaw\": 3182260, \"acRate\": \"44.0%\"}",
        "similarQuestions": "[{\"title\": \"Unique Paths\", \"titleSlug\": \"unique-paths\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Unique Paths III\", \"titleSlug\": \"unique-paths-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Path Cost in a Grid\", \"titleSlug\": \"minimum-path-cost-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paths in Matrix Whose Sum Is Divisible by K\", \"titleSlug\": \"paths-in-matrix-whose-sum-is-divisible-by-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Use dynamic programming since, from each cell, you can move to the right or down.",
          "assume dp[i][j] is the number of unique paths to reach (i, j). dp[i][j] = dp[i][j -1] + dp[i - 1][j]. Be careful when you encounter an obstacle. set its value in dp to 0."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/unique-paths-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "64",
        "questionFrontendId": "64",
        "title": "Minimum Path Sum",
        "content": "<p>Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p>\n\n<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,3,1],[1,5,1],[4,2,1]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Because the path 1 &rarr; 3 &rarr; 1 &rarr; 1 &rarr; 1 minimizes the sum.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,2,3],[4,5,6]]\n<strong>Output:</strong> 12\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 200</code></li>\n</ul>\n",
        "likes": 13528,
        "dislikes": 196,
        "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"2.6M\", \"totalAcceptedRaw\": 1744661, \"totalSubmissionRaw\": 2579715, \"acRate\": \"67.6%\"}",
        "similarQuestions": "[{\"title\": \"Unique Paths\", \"titleSlug\": \"unique-paths\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Dungeon Game\", \"titleSlug\": \"dungeon-game\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Cherry Pickup\", \"titleSlug\": \"cherry-pickup\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Path Cost in a Grid\", \"titleSlug\": \"minimum-path-cost-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Points with Cost\", \"titleSlug\": \"maximum-number-of-points-with-cost\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Cost Homecoming of a Robot in a Grid\", \"titleSlug\": \"minimum-cost-homecoming-of-a-robot-in-a-grid\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paths in Matrix Whose Sum Is Divisible by K\", \"titleSlug\": \"paths-in-matrix-whose-sum-is-divisible-by-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Check if There is a Path With Equal Number of 0's And 1's\", \"titleSlug\": \"check-if-there-is-a-path-with-equal-number-of-0s-and-1s\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Cost of a Path With Special Roads\", \"titleSlug\": \"minimum-cost-of-a-path-with-special-roads\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/minimum-path-sum/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "65",
        "questionFrontendId": "65",
        "title": "Valid Number",
        "content": "<p>Given a string <code>s</code>, return whether <code>s</code> is a <strong>valid number</strong>.<br />\n<br />\nFor example, all the following are valid numbers: <code>&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;</code>, while the following are not valid numbers: <code>&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;</code>.</p>\n\n<p>Formally, a&nbsp;<strong>valid number</strong> is defined using one of the following definitions:</p>\n\n<ol>\n\t<li>An <strong>integer number</strong> followed by an <strong>optional exponent</strong>.</li>\n\t<li>A <strong>decimal number</strong> followed by an <strong>optional exponent</strong>.</li>\n</ol>\n\n<p>An <strong>integer number</strong> is defined with an <strong>optional sign</strong> <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code> followed by <strong>digits</strong>.</p>\n\n<p>A <strong>decimal number</strong> is defined with an <strong>optional sign</strong> <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code> followed by one of the following definitions:</p>\n\n<ol>\n\t<li><strong>Digits</strong> followed by a <strong>dot</strong> <code>&#39;.&#39;</code>.</li>\n\t<li><strong>Digits</strong> followed by a <strong>dot</strong> <code>&#39;.&#39;</code> followed by <strong>digits</strong>.</li>\n\t<li>A <strong>dot</strong> <code>&#39;.&#39;</code> followed by <strong>digits</strong>.</li>\n</ol>\n\n<p>An <strong>exponent</strong> is defined with an <strong>exponent notation</strong> <code>&#39;e&#39;</code> or <code>&#39;E&#39;</code> followed by an <strong>integer number</strong>.</p>\n\n<p>The <strong>digits</strong> are defined as one or more digits.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;0&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;e&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;.&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> consists of only English letters (both uppercase and lowercase), digits (<code>0-9</code>), plus <code>&#39;+&#39;</code>, minus <code>&#39;-&#39;</code>, or dot <code>&#39;.&#39;</code>.</li>\n</ul>\n",
        "likes": 1475,
        "dislikes": 2200,
        "stats": "{\"totalAccepted\": \"498K\", \"totalSubmission\": \"2.2M\", \"totalAcceptedRaw\": 497987, \"totalSubmissionRaw\": 2218953, \"acRate\": \"22.4%\"}",
        "similarQuestions": "[{\"title\": \"String to Integer (atoi)\", \"titleSlug\": \"string-to-integer-atoi\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/valid-number/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "66",
        "questionFrontendId": "66",
        "title": "Plus One",
        "content": "<p>You are given a <strong>large integer</strong> represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>i<sup>th</sup></code> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading <code>0</code>&#39;s.</p>\n\n<p>Increment the large integer by one and return <em>the resulting array of digits</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [1,2,3]\n<strong>Output:</strong> [1,2,4]\n<strong>Explanation:</strong> The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [4,3,2,1]\n<strong>Output:</strong> [4,3,2,2]\n<strong>Explanation:</strong> The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [9]\n<strong>Output:</strong> [1,0]\n<strong>Explanation:</strong> The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n\t<li><code>digits</code> does not contain any leading <code>0</code>&#39;s.</li>\n</ul>\n",
        "likes": 11542,
        "dislikes": 5586,
        "stats": "{\"totalAccepted\": \"3.5M\", \"totalSubmission\": \"7.1M\", \"totalAcceptedRaw\": 3510868, \"totalSubmissionRaw\": 7122505, \"acRate\": \"49.3%\"}",
        "similarQuestions": "[{\"title\": \"Multiply Strings\", \"titleSlug\": \"multiply-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add Binary\", \"titleSlug\": \"add-binary\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Plus One Linked List\", \"titleSlug\": \"plus-one-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add to Array-Form of Integer\", \"titleSlug\": \"add-to-array-form-of-integer\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Reduce an Integer to 0\", \"titleSlug\": \"minimum-operations-to-reduce-an-integer-to-0\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Math"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/plus-one/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "67",
        "questionFrontendId": "67",
        "title": "Add Binary",
        "content": "<p>Given two binary strings <code>a</code> and <code>b</code>, return <em>their sum as a binary string</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> a = \"11\", b = \"1\"\n<strong>Output:</strong> \"100\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> a = \"1010\", b = \"1011\"\n<strong>Output:</strong> \"10101\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>a</code> and <code>b</code> consist&nbsp;only of <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code> characters.</li>\n\t<li>Each string does not contain leading zeros except for the zero itself.</li>\n</ul>\n",
        "likes": 10356,
        "dislikes": 1090,
        "stats": "{\"totalAccepted\": \"2.1M\", \"totalSubmission\": \"3.7M\", \"totalAcceptedRaw\": 2117890, \"totalSubmissionRaw\": 3735683, \"acRate\": \"56.7%\"}",
        "similarQuestions": "[{\"title\": \"Add Two Numbers\", \"titleSlug\": \"add-two-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Multiply Strings\", \"titleSlug\": \"multiply-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Plus One\", \"titleSlug\": \"plus-one\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Add to Array-Form of Integer\", \"titleSlug\": \"add-to-array-form-of-integer\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "String"
          },
          {
            "name": "Bit Manipulation"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/add-binary/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "68",
        "questionFrontendId": "68",
        "title": "Text Justification",
        "content": "<p>Given an array of strings <code>words</code> and a width <code>maxWidth</code>, format the text such that each line has exactly <code>maxWidth</code> characters and is fully (left and right) justified.</p>\n\n<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>&#39; &#39;</code> when necessary so that each line has exactly <code>maxWidth</code> characters.</p>\n\n<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>\n\n<p>For the last line of text, it should be left-justified, and no extra space is inserted between words.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A word is defined as a character sequence consisting of non-space characters only.</li>\n\t<li>Each word&#39;s length is guaranteed to be greater than <code>0</code> and not exceed <code>maxWidth</code>.</li>\n\t<li>The input array <code>words</code> contains at least one word.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &nbsp;&quot;This &nbsp; &nbsp;is &nbsp; &nbsp;an&quot;,\n&nbsp; &nbsp;&quot;example &nbsp;of text&quot;,\n&nbsp; &nbsp;&quot;justification. &nbsp;&quot;\n]</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &quot;What &nbsp; must &nbsp; be&quot;,\n&nbsp; &quot;acknowledgment &nbsp;&quot;,\n&nbsp; &quot;shall be &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]\n<strong>Explanation:</strong> Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;, because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,&quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;], maxWidth = 20\n<strong>Output:</strong>\n[\n&nbsp; &quot;Science &nbsp;is &nbsp;what we&quot;,\n  &quot;understand &nbsp; &nbsp; &nbsp;well&quot;,\n&nbsp; &quot;enough to explain to&quot;,\n&nbsp; &quot;a &nbsp;computer. &nbsp;Art is&quot;,\n&nbsp; &quot;everything &nbsp;else &nbsp;we&quot;,\n&nbsp; &quot;do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>words[i]</code> consists of only English letters and symbols.</li>\n\t<li><code>1 &lt;= maxWidth &lt;= 100</code></li>\n\t<li><code>words[i].length &lt;= maxWidth</code></li>\n</ul>\n",
        "likes": 4469,
        "dislikes": 5316,
        "stats": "{\"totalAccepted\": \"617.3K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 617274, \"totalSubmissionRaw\": 1231817, \"acRate\": \"50.1%\"}",
        "similarQuestions": "[{\"title\": \"Rearrange Spaces Between Words\", \"titleSlug\": \"rearrange-spaces-between-words\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Divide a String Into Groups of Size k\", \"titleSlug\": \"divide-a-string-into-groups-of-size-k\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Split Message Based on Limit\", \"titleSlug\": \"split-message-based-on-limit\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          },
          {
            "name": "Simulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/text-justification/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "69",
        "questionFrontendId": "69",
        "title": "Sqrt(x)",
        "content": "<p>Given a non-negative integer <code>x</code>, return <em>the square root of </em><code>x</code><em> rounded down to the nearest integer</em>. The returned integer should be <strong>non-negative</strong> as well.</p>\n\n<p>You <strong>must not use</strong> any built-in exponent function or operator.</p>\n\n<ul>\n\t<li>For example, do not use <code>pow(x, 0.5)</code> in c++ or <code>x ** 0.5</code> in python.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The square root of 4 is 2, so we return 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 8\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= x &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 9474,
        "dislikes": 4627,
        "stats": "{\"totalAccepted\": \"3M\", \"totalSubmission\": \"7.2M\", \"totalAcceptedRaw\": 2982934, \"totalSubmissionRaw\": 7235283, \"acRate\": \"41.2%\"}",
        "similarQuestions": "[{\"title\": \"Pow(x, n)\", \"titleSlug\": \"powx-n\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Valid Perfect Square\", \"titleSlug\": \"valid-perfect-square\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Try exploring all integers. (Credits: @annujoshi)",
          "Use the sorted property of integers to reduced the search space. (Credits: @annujoshi)"
        ],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/sqrtx/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "70",
        "questionFrontendId": "70",
        "title": "Climbing Stairs",
        "content": "<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>\n\n<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 45</code></li>\n</ul>\n",
        "likes": 24143,
        "dislikes": 1022,
        "stats": "{\"totalAccepted\": \"4.8M\", \"totalSubmission\": \"9M\", \"totalAcceptedRaw\": 4828982, \"totalSubmissionRaw\": 8968565, \"acRate\": \"53.8%\"}",
        "similarQuestions": "[{\"title\": \"Min Cost Climbing Stairs\", \"titleSlug\": \"min-cost-climbing-stairs\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Fibonacci Number\", \"titleSlug\": \"fibonacci-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"N-th Tribonacci Number\", \"titleSlug\": \"n-th-tribonacci-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Rounds to Complete All Tasks\", \"titleSlug\": \"minimum-rounds-to-complete-all-tasks\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Number of Ways to Place Houses\", \"titleSlug\": \"count-number-of-ways-to-place-houses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Ways to Reach a Position After Exactly k Steps\", \"titleSlug\": \"number-of-ways-to-reach-a-position-after-exactly-k-steps\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Ways To Build Good Strings\", \"titleSlug\": \"count-ways-to-build-good-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Frog Jump II\", \"titleSlug\": \"frog-jump-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Number of Ways to Reach the K-th Stair\", \"titleSlug\": \"find-number-of-ways-to-reach-the-k-th-stair\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"The Number of Ways to Make the Sum\", \"titleSlug\": \"the-number-of-ways-to-make-the-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "To reach nth step, what could have been your previous steps? (Think about the step sizes)"
        ],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Memoization"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/climbing-stairs/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "71",
        "questionFrontendId": "71",
        "title": "Simplify Path",
        "content": "<p>You are given an <em>absolute</em> path for a Unix-style file system, which always begins with a slash <code>&#39;/&#39;</code>. Your task is to transform this absolute path into its <strong>simplified canonical path</strong>.</p>\n\n<p>The <em>rules</em> of a Unix-style file system are as follows:</p>\n\n<ul>\n\t<li>A single period <code>&#39;.&#39;</code> represents the current directory.</li>\n\t<li>A double period <code>&#39;..&#39;</code> represents the previous/parent directory.</li>\n\t<li>Multiple consecutive slashes such as <code>&#39;//&#39;</code> and <code>&#39;///&#39;</code> are treated as a single slash <code>&#39;/&#39;</code>.</li>\n\t<li>Any sequence of periods that does <strong>not match</strong> the rules above should be treated as a <strong>valid directory or</strong> <strong>file </strong><strong>name</strong>. For example, <code>&#39;...&#39; </code>and <code>&#39;....&#39;</code> are valid directory or file names.</li>\n</ul>\n\n<p>The simplified canonical path should follow these <em>rules</em>:</p>\n\n<ul>\n\t<li>The path must start with a single slash <code>&#39;/&#39;</code>.</li>\n\t<li>Directories within the path must be separated by exactly one slash <code>&#39;/&#39;</code>.</li>\n\t<li>The path must not end with a slash <code>&#39;/&#39;</code>, unless it is the root directory.</li>\n\t<li>The path must not have any single or double periods (<code>&#39;.&#39;</code> and <code>&#39;..&#39;</code>) used to denote current or parent directories.</li>\n</ul>\n\n<p>Return the <strong>simplified canonical path</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/home/&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/home&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The trailing slash should be removed.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/home//foo/&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/home/foo&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Multiple consecutive slashes are replaced by a single one.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/home/user/Documents/../Pictures&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/home/user/Pictures&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>A double period <code>&quot;..&quot;</code> refers to the directory up a level (the parent directory).</p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/../&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Going one level up from the root directory is not possible.</p>\n</div>\n\n<p><strong class=\"example\">Example 5:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/.../a/../b/c/../d/./&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/.../b/d&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><code>&quot;...&quot;</code> is a valid name for a directory in this problem.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= path.length &lt;= 3000</code></li>\n\t<li><code>path</code> consists of English letters, digits, period <code>&#39;.&#39;</code>, slash <code>&#39;/&#39;</code> or <code>&#39;_&#39;</code>.</li>\n\t<li><code>path</code> is a valid absolute Unix path.</li>\n</ul>\n",
        "likes": 6437,
        "dislikes": 1395,
        "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"2.5M\", \"totalAcceptedRaw\": 1254193, \"totalSubmissionRaw\": 2522208, \"acRate\": \"49.7%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/simplify-path/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "72",
        "questionFrontendId": "72",
        "title": "Edit Distance",
        "content": "<p>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.</p>\n\n<p>You have the following three operations permitted on a word:</p>\n\n<ul>\n\t<li>Insert a character</li>\n\t<li>Delete a character</li>\n\t<li>Replace a character</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;horse&quot;, word2 = &quot;ros&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> \nhorse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)\nrorse -&gt; rose (remove &#39;r&#39;)\nrose -&gt; ros (remove &#39;e&#39;)\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;intention&quot;, word2 = &quot;execution&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> \nintention -&gt; inention (remove &#39;t&#39;)\ninention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)\nenention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)\nexention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)\nexection -&gt; execution (insert &#39;u&#39;)\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>\n\t<li><code>word1</code> and <code>word2</code> consist of lowercase English letters.</li>\n</ul>\n",
        "likes": 16236,
        "dislikes": 319,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"2.3M\", \"totalAcceptedRaw\": 1360206, \"totalSubmissionRaw\": 2268652, \"acRate\": \"60.0%\"}",
        "similarQuestions": "[{\"title\": \"One Edit Distance\", \"titleSlug\": \"one-edit-distance\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Delete Operation for Two Strings\", \"titleSlug\": \"delete-operation-for-two-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum ASCII Delete Sum for Two Strings\", \"titleSlug\": \"minimum-ascii-delete-sum-for-two-strings\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Uncrossed Lines\", \"titleSlug\": \"uncrossed-lines\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum White Tiles After Covering With Carpets\", \"titleSlug\": \"minimum-white-tiles-after-covering-with-carpets\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Palindrome After Substring Concatenation II\", \"titleSlug\": \"longest-palindrome-after-substring-concatenation-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Steps to Convert String with Operations\", \"titleSlug\": \"minimum-steps-to-convert-string-with-operations\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/edit-distance/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "73",
        "questionFrontendId": "73",
        "title": "Set Matrix Zeroes",
        "content": "<p>Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>&#39;s.</p>\n\n<p>You must do it <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in place</a>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg\" style=\"width: 450px; height: 169px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>Output:</strong> [[1,0,1],[0,0,0],[1,0,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg\" style=\"width: 450px; height: 137px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n<strong>Output:</strong> [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[0].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>A straightforward solution using <code>O(mn)</code> space is probably a bad idea.</li>\n\t<li>A simple improvement uses <code>O(m + n)</code> space, but still not the best solution.</li>\n\t<li>Could you devise a constant space solution?</li>\n</ul>\n",
        "likes": 16822,
        "dislikes": 848,
        "stats": "{\"totalAccepted\": \"2.4M\", \"totalSubmission\": \"3.9M\", \"totalAcceptedRaw\": 2423524, \"totalSubmissionRaw\": 3897742, \"acRate\": \"62.2%\"}",
        "similarQuestions": "[{\"title\": \"Game of Life\", \"titleSlug\": \"game-of-life\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Number of Laser Beams in a Bank\", \"titleSlug\": \"number-of-laser-beams-in-a-bank\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Remove Adjacent Ones in Matrix\", \"titleSlug\": \"minimum-operations-to-remove-adjacent-ones-in-matrix\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Remove All Ones With Row and Column Flips II\", \"titleSlug\": \"remove-all-ones-with-row-and-column-flips-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "If any cell of the matrix has a zero we can record its row and column number using additional memory.\r\nBut if you don't want to use extra memory then you can manipulate the array instead. i.e. simulating exactly what the question says.",
          "Setting cell values to zero on the fly while iterating might lead to discrepancies. What if you use some other integer value as your marker?\r\nThere is still a better approach for this problem with O(1) space.",
          "We could have used 2 sets to keep a record of rows/columns which need to be set to zero. But for an O(1) space solution, you can use one of the rows and and one of the columns to keep track of this information.",
          "We can use the first cell of every row and column as a flag. This flag would determine whether a row or column has been set to zero."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Hash Table"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/set-matrix-zeroes/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "74",
        "questionFrontendId": "74",
        "title": "Search a 2D Matrix",
        "content": "<p>You are given an <code>m x n</code> integer matrix <code>matrix</code> with the following two properties:</p>\n\n<ul>\n\t<li>Each row is sorted in non-decreasing order.</li>\n\t<li>The first integer of each row is greater than the last integer of the previous row.</li>\n</ul>\n\n<p>Given an integer <code>target</code>, return <code>true</code> <em>if</em> <code>target</code> <em>is in</em> <code>matrix</code> <em>or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>You must write a solution in <code>O(log(m * n))</code> time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= matrix[i][j], target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 17613,
        "dislikes": 476,
        "stats": "{\"totalAccepted\": \"2.7M\", \"totalSubmission\": \"5.1M\", \"totalAcceptedRaw\": 2717957, \"totalSubmissionRaw\": 5096592, \"acRate\": \"53.3%\"}",
        "similarQuestions": "[{\"title\": \"Search a 2D Matrix II\", \"titleSlug\": \"search-a-2d-matrix-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Split Message Based on Limit\", \"titleSlug\": \"split-message-based-on-limit\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/search-a-2d-matrix/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "75",
        "questionFrontendId": "75",
        "title": "Sort Colors",
        "content": "<p>Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong><a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a> </strong>so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p>\n\n<p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p>\n\n<p>You must solve this problem without using the library&#39;s sort function.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,0,2,1,1,0]\n<strong>Output:</strong> [0,0,1,1,2,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,0,1]\n<strong>Output:</strong> [0,1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Could you come up with a one-pass algorithm using only&nbsp;constant extra space?</p>\n",
        "likes": 21176,
        "dislikes": 753,
        "stats": "{\"totalAccepted\": \"3.5M\", \"totalSubmission\": \"5M\", \"totalAcceptedRaw\": 3468567, \"totalSubmissionRaw\": 5034933, \"acRate\": \"68.9%\"}",
        "similarQuestions": "[{\"title\": \"Sort List\", \"titleSlug\": \"sort-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Wiggle Sort\", \"titleSlug\": \"wiggle-sort\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Wiggle Sort II\", \"titleSlug\": \"wiggle-sort-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "A rather straight forward solution is a two-pass algorithm using counting sort.",
          "Iterate the array counting number of 0's, 1's, and 2's.",
          "Overwrite array with the total number of 0's, then 1's and followed by 2's."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/sort-colors/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "76",
        "questionFrontendId": "76",
        "title": "Minimum Window Substring",
        "content": "<p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window</strong></em> <span data-keyword=\"substring-nonempty\"><strong><em>substring</em></strong></span><em> of </em><code>s</code><em> such that every character in </em><code>t</code><em> (<strong>including duplicates</strong>) is included in the window</em>. If there is no such substring, return <em>the empty string </em><code>&quot;&quot;</code>.</p>\n\n<p>The testcases will be generated such that the answer is <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\n<strong>Output:</strong> &quot;BANC&quot;\n<strong>Explanation:</strong> The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;a&quot;\n<strong>Output:</strong> &quot;a&quot;\n<strong>Explanation:</strong> The entire string s is the minimum window.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;aa&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> Both &#39;a&#39;s from t must be included in the window.\nSince the largest window of s only has one &#39;a&#39;, return empty string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == s.length</code></li>\n\t<li><code>n == t.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?</p>\n",
        "likes": 19813,
        "dislikes": 838,
        "stats": "{\"totalAccepted\": \"2M\", \"totalSubmission\": \"4.3M\", \"totalAcceptedRaw\": 2018808, \"totalSubmissionRaw\": 4324501, \"acRate\": \"46.7%\"}",
        "similarQuestions": "[{\"title\": \"Substring with Concatenation of All Words\", \"titleSlug\": \"substring-with-concatenation-of-all-words\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Size Subarray Sum\", \"titleSlug\": \"minimum-size-subarray-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sliding Window Maximum\", \"titleSlug\": \"sliding-window-maximum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Permutation in String\", \"titleSlug\": \"permutation-in-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest Range Covering Elements from K Lists\", \"titleSlug\": \"smallest-range-covering-elements-from-k-lists\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Window Subsequence\", \"titleSlug\": \"minimum-window-subsequence\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Substrings That Can Be Rearranged to Contain a String II\", \"titleSlug\": \"count-substrings-that-can-be-rearranged-to-contain-a-string-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Substrings That Can Be Rearranged to Contain a String I\", \"titleSlug\": \"count-substrings-that-can-be-rearranged-to-contain-a-string-i\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "Use two pointers to create a window of letters in s, which would have all the characters from t.",
          "Expand the right pointer until all the characters of t are covered.",
          "Once all the characters are covered, move the left pointer and ensure that all the characters are still covered to minimize the subarray size.",
          "Continue expanding the right and left pointers until you reach the end of s."
        ],
        "topicTags": [
          {
            "name": "Hash Table"
          },
          {
            "name": "String"
          },
          {
            "name": "Sliding Window"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/minimum-window-substring/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "77",
        "questionFrontendId": "77",
        "title": "Combinations",
        "content": "<p>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers chosen from the range</em> <code>[1, n]</code>.</p>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, k = 2\n<strong>Output:</strong> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n<strong>Explanation:</strong> There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 1\n<strong>Output:</strong> [[1]]\n<strong>Explanation:</strong> There is 1 choose 1 = 1 total combination.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "likes": 8829,
        "dislikes": 250,
        "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 1264865, \"totalSubmissionRaw\": 1709345, \"acRate\": \"74.0%\"}",
        "similarQuestions": "[{\"title\": \"Combination Sum\", \"titleSlug\": \"combination-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutations\", \"titleSlug\": \"permutations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/combinations/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "78",
        "questionFrontendId": "78",
        "title": "Subsets",
        "content": "<p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible</em> <span data-keyword=\"subset\"><em>subsets</em></span> <em>(the power set)</em>.</p>\n\n<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [[],[0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>All the numbers of&nbsp;<code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "likes": 18959,
        "dislikes": 334,
        "stats": "{\"totalAccepted\": \"2.9M\", \"totalSubmission\": \"3.5M\", \"totalAcceptedRaw\": 2871847, \"totalSubmissionRaw\": 3507969, \"acRate\": \"81.9%\"}",
        "similarQuestions": "[{\"title\": \"Subsets II\", \"titleSlug\": \"subsets-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Generalized Abbreviation\", \"titleSlug\": \"generalized-abbreviation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Letter Case Permutation\", \"titleSlug\": \"letter-case-permutation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Array Given Subset Sums\", \"titleSlug\": \"find-array-given-subset-sums\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Number of Maximum Bitwise-OR Subsets\", \"titleSlug\": \"count-number-of-maximum-bitwise-or-subsets\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Overview: Solution Pattern\n\nLet us first review the problems of Permutations / Combinations / Subsets, since they are quite similar to each other and there are some common strategies to solve them.\n\nFirst, their solution space is often quite large:\n\n- [Permutations](https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n): $$N!$$. \n\n- [Combinations](https://en.wikipedia.org/wiki/Combination#Number_of_k-combinations): $$C_N^k = \\frac{N!}{(N - k)! k!}$$\n\n- Subsets: $$2^N$$, since each element could be absent or present. \n\nGiven their exponential solution space, it is tricky to ensure that the generated solutions are _**complete**_ and _**non-redundant**_. It is essential to have a clear and easy-to-reason strategy.\n\nThere are generally three strategies to do it:\n\n- Iterative\n\n- Recursion/Backtracking\n\n- Lexicographic generation based on the mapping between binary bitmasks and the corresponding permutations / combinations / subsets.\n\nAs one would see later, the third method could be a good candidate for the interview because it simplifies the problem to the generation of binary numbers, therefore it is easy to implement and verify that no solution is missing.\n\nBesides, as a bonus, it generates lexicographically sorted output for the sorted inputs.\n\n\n---\n### Approach 1: Cascading\n\n#### Intuition\n\nLet's start from an empty subset in the output list. At each step, one takes a new integer into consideration and generates new subsets from the existing ones. \n\n![diff](../Figures/78/recursion.png)\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/GfSoguWr/shared\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"GfSoguWr\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $$\\mathcal{O}(N \\times 2^N)$$ to generate all subsets and then copy them into the output list. \n    \n* Space complexity: $$\\mathcal{O}(N \\times 2^N)$$. This is exactly the number of solutions for subsets multiplied by the number $$N$$ of elements to keep for each subset.  \n    - For a given number, it could be present or absent (_i.e._ binary choice) in a subset solution. As a result, for $$N$$ numbers, we would have in total $$2^N$$ choices (solutions). \n<br />\n<br />\n\n\n---\n### Approach 2: Backtracking\n\n#### Algorithm\n\n>Power set is all possible combinations of all possible _lengths_, from 0 to n.\n\nGiven the definition, the problem can also be interpreted as finding the _power set_ from a sequence.\n\nSo, this time let us loop over the length of combination, rather than the candidate numbers, and generate all combinations for a given length with the help of _backtracking_ technique.\n\n![diff](../Figures/78/combinations.png)\n\n>[Backtracking](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/) is an algorithm for finding all solutions by exploring all potential candidates. If the solution candidate turns out to be _not_ a solution (or at least not the _last_ one), the backtracking algorithm discards it by making some changes on the previous step, *i.e.* _backtracks_ and then tries again.\n\n![diff](../Figures/78/backtracking.png)\n\n#### Algorithm\n\nWe define a backtrack function named `backtrack(first, curr)` that takes the index of the first element to add and a current combination as arguments.\n\n- If the current combination is done, we add the combination to the final output.\n\n- Otherwise, we iterate over the indexes `i` from `first` to the length of the entire sequence `n`.\n\n    - Add integer `nums[i]` into the current combination `curr`.\n\n    - Proceed to add more integers into the combination: `backtrack(i + 1, curr)`.\n\n    - Backtrack by removing `nums[i]` from `curr`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/X6GCLJ3t/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"X6GCLJ3t\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $$\\mathcal{O}(N \\times 2^N)$$ to generate all subsets and then copy them into the output list.\n \n* Space complexity: $$\\mathcal{O}(N)$$. We are using $$O(N)$$ space to maintain `curr`, and are modifying `curr` in-place with backtracking. Note that for space complexity analysis, we do not count space that is *only* used for the purpose of returning output, so the `output` array is ignored.\n\n\n---\n### Approach 3: Lexicographic (Binary Sorted) Subsets\n\n#### Intuition\n\nThe idea of this solution is originated from [Donald E. Knuth](https://www-cs-faculty.stanford.edu/~knuth/taocp.html).\n\n>The idea is that we map each subset to a bitmask of length n,\nwhere `1` on the i*th* position in bitmask means the presence of `nums[i]`\nin the subset, and `0` means its absence. \n\n![diff](../Figures/78/bitmask4.png)\n\nFor instance, the bitmask `0..00` (all zeros) corresponds to an empty subset, \nand the bitmask `1..11` (all ones) corresponds to the entire input array `nums`. \n\nHence to solve the initial problem, we just need to generate n bitmasks\nfrom `0..00` to `1..11`. \n\nIt might seem simple at first glance to generate binary numbers, but \nthe real problem here is how to deal with \n[zero left padding](https://en.wikipedia.org/wiki/Padding_(cryptography)#Zero_padding),\nbecause one has to generate bitmasks of fixed length, _i.e._ `001` and not just `1`.\nFor that one could use standard bit manipulation trick:\n\n<iframe src=\"https://leetcode.com/playground/PtHUHaeY/shared\" frameBorder=\"0\" width=\"100%\" height=\"140\" name=\"PtHUHaeY\"></iframe>\n\nor keep it simple stupid and shift iteration limits:\n\n<iframe src=\"https://leetcode.com/playground/4XWEGcWd/shared\" frameBorder=\"0\" width=\"100%\" height=\"123\" name=\"4XWEGcWd\"></iframe>\n\n#### Algorithm\n\n- Generate all possible binary bitmasks of length n.\n\n- Map a subset to each bitmask: \n`1` on the i*th* position in bitmask means the presence of `nums[i]`\nin the subset, and `0` means its absence. \n\n- Return output list.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/DwHHy2yt/shared\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"DwHHy2yt\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $$\\mathcal{O}(N \\times 2^N)$$ to generate all subsets \nand then copy them into output list.\n    \n* Space complexity: $$\\mathcal{O}(N)$$ to store the bitset\nof length $$N$$. Note that for space complexity analysis, we do not count space that is *only* used for the purpose of returning output, so the `output` array is ignored."
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/subsets/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "79",
        "questionFrontendId": "79",
        "title": "Word Search",
        "content": "<p>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p>\n\n<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/word3.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n = board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 6</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 15</code></li>\n\t<li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you use search pruning to make your solution faster with a larger <code>board</code>?</p>\n",
        "likes": 17432,
        "dislikes": 746,
        "stats": "{\"totalAccepted\": \"2.4M\", \"totalSubmission\": \"5.1M\", \"totalAcceptedRaw\": 2371424, \"totalSubmissionRaw\": 5088729, \"acRate\": \"46.6%\"}",
        "similarQuestions": "[{\"title\": \"Word Search II\", \"titleSlug\": \"word-search-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Matrix"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/word-search/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "80",
        "questionFrontendId": "80",
        "title": "Remove Duplicates from Sorted Array II",
        "content": "<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove some duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a> such that each unique element appears <strong>at most twice</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p>\n\n<p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code>&nbsp;should hold the final result. It does not matter what you leave beyond the first&nbsp;<code>k</code>&nbsp;elements.</p>\n\n<p>Return <code>k</code><em> after placing the final result in the first </em><code>k</code><em> slots of </em><code>nums</code>.</p>\n\n<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></strong> with O(1) extra memory.</p>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The judge will test your solution with the following code:</p>\n\n<pre>\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</pre>\n\n<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1,2,2,3]\n<strong>Output:</strong> 5, nums = [1,1,2,2,3,_]\n<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,1,1,1,1,2,3,3]\n<strong>Output:</strong> 7, nums = [0,0,1,1,2,3,3,_,_]\n<strong>Explanation:</strong> Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n",
        "likes": 8089,
        "dislikes": 1505,
        "stats": "{\"totalAccepted\": \"1.8M\", \"totalSubmission\": \"2.8M\", \"totalAcceptedRaw\": 1811869, \"totalSubmissionRaw\": 2827941, \"acRate\": \"64.1%\"}",
        "similarQuestions": "[{\"title\": \"Remove Duplicates from Sorted Array\", \"titleSlug\": \"remove-duplicates-from-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "81",
        "questionFrontendId": "81",
        "title": "Search in Rotated Sorted Array II",
        "content": "<p>There is an integer array <code>nums</code> sorted in non-decreasing order (not necessarily with <strong>distinct</strong> values).</p>\n\n<p>Before being passed to your function, <code>nums</code> is <strong>rotated</strong> at an unknown pivot index <code>k</code> (<code>0 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,4,4,5,6,6,7]</code> might be rotated at pivot index <code>5</code> and become <code>[4,5,6,6,7,0,1,2,4,4]</code>.</p>\n\n<p>Given the array <code>nums</code> <strong>after</strong> the rotation and an integer <code>target</code>, return <code>true</code><em> if </em><code>target</code><em> is in </em><code>nums</code><em>, or </em><code>false</code><em> if it is not in </em><code>nums</code><em>.</em></p>\n\n<p>You must decrease the overall operation steps as much as possible.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,5,6,0,0,1,2], target = 0\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,5,6,0,0,1,2], target = 3\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is guaranteed to be rotated at some pivot.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> This problem is similar to&nbsp;<a href=\"/problems/search-in-rotated-sorted-array/description/\" target=\"_blank\">Search in Rotated Sorted Array</a>, but&nbsp;<code>nums</code> may contain <strong>duplicates</strong>. Would this affect the runtime complexity? How and why?</p>\n",
        "likes": 9483,
        "dislikes": 1114,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"2.9M\", \"totalAcceptedRaw\": 1151567, \"totalSubmissionRaw\": 2909976, \"acRate\": \"39.6%\"}",
        "similarQuestions": "[{\"title\": \"Search in Rotated Sorted Array\", \"titleSlug\": \"search-in-rotated-sorted-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Binary Search"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "82",
        "questionFrontendId": "82",
        "title": "Remove Duplicates from Sorted List II",
        "content": "<p>Given the <code>head</code> of a sorted linked list, <em>delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list</em>. Return <em>the linked list <strong>sorted</strong> as well</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg\" style=\"width: 500px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,3,4,4,5]\n<strong>Output:</strong> [1,2,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg\" style=\"width: 500px; height: 205px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,1,2,3]\n<strong>Output:</strong> [2,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 300]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>The list is guaranteed to be <strong>sorted</strong> in ascending order.</li>\n</ul>\n",
        "likes": 9568,
        "dislikes": 278,
        "stats": "{\"totalAccepted\": \"1M\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 1042850, \"totalSubmissionRaw\": 2040612, \"acRate\": \"51.1%\"}",
        "similarQuestions": "[{\"title\": \"Remove Duplicates from Sorted List\", \"titleSlug\": \"remove-duplicates-from-sorted-list\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Remove Duplicates From an Unsorted Linked List\", \"titleSlug\": \"remove-duplicates-from-an-unsorted-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "83",
        "questionFrontendId": "83",
        "title": "Remove Duplicates from Sorted List",
        "content": "<p>Given the <code>head</code> of a sorted linked list, <em>delete all duplicates such that each element appears only once</em>. Return <em>the linked list <strong>sorted</strong> as well</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/list1.jpg\" style=\"width: 302px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,2]\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/list2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,2,3,3]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 300]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>The list is guaranteed to be <strong>sorted</strong> in ascending order.</li>\n</ul>\n",
        "likes": 9699,
        "dislikes": 358,
        "stats": "{\"totalAccepted\": \"2.2M\", \"totalSubmission\": \"4M\", \"totalAcceptedRaw\": 2229306, \"totalSubmissionRaw\": 3978425, \"acRate\": \"56.0%\"}",
        "similarQuestions": "[{\"title\": \"Remove Duplicates from Sorted List II\", \"titleSlug\": \"remove-duplicates-from-sorted-list-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Remove Duplicates From an Unsorted Linked List\", \"titleSlug\": \"remove-duplicates-from-an-unsorted-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "84",
        "questionFrontendId": "84",
        "title": "Largest Rectangle in Histogram",
        "content": "<p>Given an array of integers <code>heights</code> representing the histogram&#39;s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" style=\"width: 522px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> heights = [2,1,5,6,2,3]\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg\" style=\"width: 202px; height: 362px;\" />\n<pre>\n<strong>Input:</strong> heights = [2,4]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= heights[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 19255,
        "dislikes": 373,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"2.9M\", \"totalAcceptedRaw\": 1436352, \"totalSubmissionRaw\": 2927942, \"acRate\": \"49.1%\"}",
        "similarQuestions": "[{\"title\": \"Maximal Rectangle\", \"titleSlug\": \"maximal-rectangle\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Score of a Good Subarray\", \"titleSlug\": \"maximum-score-of-a-good-subarray\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Monotonic Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "85",
        "questionFrontendId": "85",
        "title": "Maximal Rectangle",
        "content": "<p>Given a <code>rows x cols</code>&nbsp;binary <code>matrix</code> filled with <code>0</code>&#39;s and <code>1</code>&#39;s, find the largest rectangle containing only <code>1</code>&#39;s and return <em>its area</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg\" style=\"width: 402px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The maximal rectangle is shown in the above picture.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[&quot;0&quot;]]\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[&quot;1&quot;]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>rows == matrix.length</code></li>\n\t<li><code>cols == matrix[i].length</code></li>\n\t<li><code>1 &lt;= rows, cols &lt;= 200</code></li>\n\t<li><code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "likes": 11941,
        "dislikes": 224,
        "stats": "{\"totalAccepted\": \"760.5K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 760454, \"totalSubmissionRaw\": 1316088, \"acRate\": \"57.8%\"}",
        "similarQuestions": "[{\"title\": \"Largest Rectangle in Histogram\", \"titleSlug\": \"largest-rectangle-in-histogram\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximal Square\", \"titleSlug\": \"maximal-square\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Sorted Submatrices With Maximum Element at Most K\", \"titleSlug\": \"find-sorted-submatrices-with-maximum-element-at-most-k\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Stack"
          },
          {
            "name": "Matrix"
          },
          {
            "name": "Monotonic Stack"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/maximal-rectangle/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "86",
        "questionFrontendId": "86",
        "title": "Partition List",
        "content": "<p>Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes <strong>less than</strong> <code>x</code> come before nodes <strong>greater than or equal</strong> to <code>x</code>.</p>\n\n<p>You should <strong>preserve</strong> the original relative order of the nodes in each of the two partitions.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/partition.jpg\" style=\"width: 662px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,4,3,2,5,2], x = 3\n<strong>Output:</strong> [1,2,2,4,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [2,1], x = 2\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 200]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-200 &lt;= x &lt;= 200</code></li>\n</ul>\n",
        "likes": 7960,
        "dislikes": 978,
        "stats": "{\"totalAccepted\": \"861.9K\", \"totalSubmission\": \"1.4M\", \"totalAcceptedRaw\": 861852, \"totalSubmissionRaw\": 1427916, \"acRate\": \"60.4%\"}",
        "similarQuestions": "[{\"title\": \"Partition Array According to Given Pivot\", \"titleSlug\": \"partition-array-according-to-given-pivot\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          },
          {
            "name": "Two Pointers"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/partition-list/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "87",
        "questionFrontendId": "87",
        "title": "Scramble String",
        "content": "<p>We can scramble a string s to get a string t using the following algorithm:</p>\n\n<ol>\n\t<li>If the length of the string is 1, stop.</li>\n\t<li>If the length of the string is &gt; 1, do the following:\n\t<ul>\n\t\t<li>Split the string into two non-empty substrings at a random index, i.e., if the string is <code>s</code>, divide it to <code>x</code> and <code>y</code> where <code>s = x + y</code>.</li>\n\t\t<li><strong>Randomly</strong>&nbsp;decide to swap the two substrings or to keep them in the same order. i.e., after this step, <code>s</code> may become <code>s = x + y</code> or <code>s = y + x</code>.</li>\n\t\t<li>Apply step 1 recursively on each of the two substrings <code>x</code> and <code>y</code>.</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>Given two strings <code>s1</code> and <code>s2</code> of <strong>the same length</strong>, return <code>true</code> if <code>s2</code> is a scrambled string of <code>s1</code>, otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> One possible scenario applied on s1 is:\n&quot;great&quot; --&gt; &quot;gr/eat&quot; // divide at random index.\n&quot;gr/eat&quot; --&gt; &quot;gr/eat&quot; // random decision is not to swap the two substrings and keep them in order.\n&quot;gr/eat&quot; --&gt; &quot;g/r / e/at&quot; // apply the same algorithm recursively on both substrings. divide at random index each of them.\n&quot;g/r / e/at&quot; --&gt; &quot;r/g / e/at&quot; // random decision was to swap the first substring and to keep the second substring in the same order.\n&quot;r/g / e/at&quot; --&gt; &quot;r/g / e/ a/t&quot; // again apply the algorithm recursively, divide &quot;at&quot; to &quot;a/t&quot;.\n&quot;r/g / e/ a/t&quot; --&gt; &quot;r/g / e/ a/t&quot; // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is &quot;rgeat&quot; which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;a&quot;, s2 = &quot;a&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li><code>1 &lt;= s1.length &lt;= 30</code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n</ul>\n",
        "likes": 3600,
        "dislikes": 1307,
        "stats": "{\"totalAccepted\": \"299.7K\", \"totalSubmission\": \"686.7K\", \"totalAcceptedRaw\": 299653, \"totalSubmissionRaw\": 686667, \"acRate\": \"43.6%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Hard",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Approach: Dynamic Programming\n\n#### Intuition\n\nWe have a recursive definition of scrambling a string `s`. First, we divide `s` into `x` and `y`. Then we either keep `s` as `x + y` or swap them and get `y + x`. After that, we scramble `x` and `y` independently. Let `x'` denote the scrambled `x` and `y'` denote the scrambled `y`. `s` will eventually become `x' + y'` or `y' + x'`.\n\n![split](../Figures/87/diagram2.drawio.png)\n\nHow do we check whether a given string `t` is a scrambled string of `s`? First, we choose an index and cut `s` into `x` and `y` (`s = x + y`). Then, we see if we can cut `t` into `x'` and `y'` (`t = x' + y'` if we do not swap or `t = y' + x'` if we do). Since verifying that `x'` is a scrambled `x` and `y'` is scrambled `y` are smaller subproblems, we will solve the problem using dynamic programming.\n\nWe have two strings `s1` and `s2`.\n\nFor each given dp state, we need 3 variables: `length`, `i`, and `j`.\n\nEach state will focus on two substrings. The first one will be a substring of `s1`, starting at index `i` with length equal to `length` - let's call this substring `s`. The second one will be a substring of `s2`, starting at index `j` with `length` - let's call this substring `t`.\n\nLet `dp[length][i][j]` be a boolean representing whether `t` is a scrambled version of `s`.\n\nThe base case, as defined by the problem is when `length = 1`. Here we do not have to split strings into smaller ones, so we can easily compare the corresponding characters: `dp[1][i][j]` is `true` when `s1[i]` equals `s2[j]`, and `false` otherwise.\n\nNow we need to write down the transitions of `dp`. We will use the following image as an example during the explanations.\n\n![split](../Figures/87/diagram.drawio.png)\n\nAt each state, we need to perform a split on `s1`. We will consider all possible splits. If we are currently considering a substring with a length of `length`, then we could perform a split at any index `newLength`, where `0 < newLength < length`. (Here, `newLength` represents the length of the left string after the split). A split gives us two new strings:\n\n- A substring of `s1` starting at index `i` and ending with index `i + newLength - 1`. This string has a length of `newLength` (Blue in the picture)\n\n- A substring of `s1` starting at index `i + newLength` and ending at index `i + length - 1`. This string has a length of `length - newLength`. (Yellow in the picture)\n\nFor each split, we have two cases:\n\n* Do not swap the blue and yellow parts. The corresponding substrings of `s2` must be scrambled versions of the substrings we just created by splitting `s1`. This means both `dp[newLength][i][j]` (representing the blue parts) and `dp[length - newLength][i + newLength][j + newLength]` (representing the yellow parts) must be true.\n* Swap the blue and yellow parts. As you can see in the image, this misaligns the blue and yellow parts between `s1` and `s2`, but we still need the parts to match (we still need the blue part of `s1` to be a scrambled version of the blue part of `s2`, same with the yellow part). What are the new starting indices? For blue, it's `s1` starting with `i` and `s2` starting with `j + length - newLength`. For yellow, it's `s1` starting with `i + newLength` and `s2` starting with `j`. Thus, we need both `dp[newLength][i][j+length-newLength]` and `dp[length-newLength][i+newLength][j]` to be `true`.\n\nNow we can formally write down the transitions. For `length > 1`, `dp[length][i][j]` is `true` if and only if for at least one `newLength` where `0 < newLength < length`:\n\n`(dp[newLength][i][j] && dp[length-newLength][i+newLength][j+newLength]) || (dp[newLength][i][j+length-newLength] && dp[length-newLength][i+newLength][j])` is `true`.\n\nLet `n` denote the length of the input strings. The answer to the problem is `dp[n][0][0]`, as starting at index `0` with length `n` is considering the entire input string.\n\n#### Algorithm\n\n1. Iterate `i` from `0` to `n-1`.\n\t* Iterate `j` from `0` to `n-1`.\n\t\t* Set `dp[1][i][j]` to the boolean value of `s1[i] == s2[j]`. (The base case of the DP).\n2. Iterate `length` from `2` to `n`.\n\t* Iterate `i` from `0` to `n + 1 - length`.\n\t\t* Iterate `j` from `0` to `n + 1 - length`.\n\t\t\t* Iterate `newLength` from `1` to `length - 1`.\n\t\t\t\t* If `dp[newLength][i][j] && dp[length-newLength][i+newLength][j+newLength]) || (dp[newLength][i][j+l-newLength] && dp[l-newLength][i+newLength][j]` is `true`, set `dp[length][i][j]` to `true`.\n3. Return `dp[n][0][0]`.\n\n#### Implementation\n\n\n<iframe src=\"https://leetcode.com/playground/XJvjmW6h/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"XJvjmW6h\"></iframe>\n\n\n#### Complexity Analysis\n\n* Time complexity: $O(n^4)$.\n\nWe have four nested for loops (for `length`, `i`, `j`, `newLength`), each doing $O(n)$ iterations.\n\n* Space complexity: $O(n^3)$.\n\nWe store the matrix `dp[n+1][n][n]` for dynamic programming."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/scramble-string/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "88",
        "questionFrontendId": "88",
        "title": "Merge Sorted Array",
        "content": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p>\n\n<p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p>\n\n<p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array </em><code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n<strong>Output:</strong> [1,2,2,3,5,6]\n<strong>Explanation:</strong> The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [<u>1</u>,<u>2</u>,2,<u>3</u>,5,6] with the underlined elements coming from nums1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1], m = 1, nums2 = [], n = 0\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [0], m = 0, nums2 = [1], n = 1\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m + n</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up: </strong>Can you come up with an algorithm that runs in <code>O(m + n)</code> time?</p>\n",
        "likes": 18431,
        "dislikes": 2577,
        "stats": "{\"totalAccepted\": \"5.3M\", \"totalSubmission\": \"9.8M\", \"totalAcceptedRaw\": 5327899, \"totalSubmissionRaw\": 9843336, \"acRate\": \"54.1%\"}",
        "similarQuestions": "[{\"title\": \"Merge Two Sorted Lists\", \"titleSlug\": \"merge-two-sorted-lists\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Squares of a Sorted Array\", \"titleSlug\": \"squares-of-a-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Interval List Intersections\", \"titleSlug\": \"interval-list-intersections\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Take K of Each Character From Left and Right\", \"titleSlug\": \"take-k-of-each-character-from-left-and-right\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [
          "You can easily solve this problem if you simply think about two elements at a time rather than two arrays. We know that each of the individual arrays is sorted. What we don't know is how they will intertwine. Can we take a local decision and arrive at an optimal solution?",
          "If you simply consider one element each at a time from the two arrays and make a decision and proceed accordingly, you will arrive at the optimal solution."
        ],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Two Pointers"
          },
          {
            "name": "Sorting"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/merge-sorted-array/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "89",
        "questionFrontendId": "89",
        "title": "Gray Code",
        "content": "<p>An <strong>n-bit gray code sequence</strong> is a sequence of <code>2<sup>n</sup></code> integers where:</p>\n\n<ul>\n\t<li>Every integer is in the <strong>inclusive</strong> range <code>[0, 2<sup>n</sup> - 1]</code>,</li>\n\t<li>The first integer is <code>0</code>,</li>\n\t<li>An integer appears <strong>no more than once</strong> in the sequence,</li>\n\t<li>The binary representation of every pair of <strong>adjacent</strong> integers differs by <strong>exactly one bit</strong>, and</li>\n\t<li>The binary representation of the <strong>first</strong> and <strong>last</strong> integers differs by <strong>exactly one bit</strong>.</li>\n</ul>\n\n<p>Given an integer <code>n</code>, return <em>any valid <strong>n-bit gray code sequence</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> [0,1,3,2]\n<strong>Explanation:</strong>\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 0<u>0</u> and 0<u>1</u> differ by one bit\n- <u>0</u>1 and <u>1</u>1 differ by one bit\n- 1<u>1</u> and 1<u>0</u> differ by one bit\n- <u>1</u>0 and <u>0</u>0 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- <u>0</u>0 and <u>1</u>0 differ by one bit\n- 1<u>0</u> and 1<u>1</u> differ by one bit\n- <u>1</u>1 and <u>0</u>1 differ by one bit\n- 0<u>1</u> and 0<u>0</u> differ by one bit\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 16</code></li>\n</ul>\n",
        "likes": 2497,
        "dislikes": 2829,
        "stats": "{\"totalAccepted\": \"397.6K\", \"totalSubmission\": \"623.6K\", \"totalAcceptedRaw\": 397571, \"totalSubmissionRaw\": 623605, \"acRate\": \"63.8%\"}",
        "similarQuestions": "[{\"title\": \"1-bit and 2-bit Characters\", \"titleSlug\": \"1-bit-and-2-bit-characters\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/gray-code/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "90",
        "questionFrontendId": "90",
        "title": "Subsets II",
        "content": "<p>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible</em> <span data-keyword=\"subset\"><em>subsets</em></span><em> (the power set)</em>.</p>\n\n<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,2]\n<strong>Output:</strong> [[],[1],[1,2],[1,2,2],[2],[2,2]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [[],[0]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n",
        "likes": 10772,
        "dislikes": 402,
        "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"2.3M\", \"totalAcceptedRaw\": 1404765, \"totalSubmissionRaw\": 2315388, \"acRate\": \"60.7%\"}",
        "similarQuestions": "[{\"title\": \"Subsets\", \"titleSlug\": \"subsets\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Array Given Subset Sums\", \"titleSlug\": \"find-array-given-subset-sums\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Array"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Bit Manipulation"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/subsets-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "91",
        "questionFrontendId": "91",
        "title": "Decode Ways",
        "content": "<p>You have intercepted a secret message encoded as a string of numbers. The message is <strong>decoded</strong> via the following mapping:</p>\n\n<p><code>&quot;1&quot; -&gt; &#39;A&#39;<br />\n&quot;2&quot; -&gt; &#39;B&#39;<br />\n...<br />\n&quot;25&quot; -&gt; &#39;Y&#39;<br />\n&quot;26&quot; -&gt; &#39;Z&#39;</code></p>\n\n<p>However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (<code>&quot;2&quot;</code> and <code>&quot;5&quot;</code> vs <code>&quot;25&quot;</code>).</p>\n\n<p>For example, <code>&quot;11106&quot;</code> can be decoded into:</p>\n\n<ul>\n\t<li><code>&quot;AAJF&quot;</code> with the grouping <code>(1, 1, 10, 6)</code></li>\n\t<li><code>&quot;KJF&quot;</code> with the grouping <code>(11, 10, 6)</code></li>\n\t<li>The grouping <code>(1, 11, 06)</code> is invalid because <code>&quot;06&quot;</code> is not a valid code (only <code>&quot;6&quot;</code> is valid).</li>\n</ul>\n\n<p>Note: there may be strings that are impossible to decode.<br />\n<br />\nGiven a string s containing only digits, return the <strong>number of ways</strong> to <strong>decode</strong> it. If the entire string cannot be decoded in any valid way, return <code>0</code>.</p>\n\n<p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;12&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>&quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;226&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">3</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>&quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;06&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>&quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;). In this case, the string is not a valid encoding, so return 0.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> contains only digits and may contain leading zero(s).</li>\n</ul>\n",
        "likes": 12755,
        "dislikes": 4608,
        "stats": "{\"totalAccepted\": \"1.6M\", \"totalSubmission\": \"4.3M\", \"totalAcceptedRaw\": 1595269, \"totalSubmissionRaw\": 4258943, \"acRate\": \"37.5%\"}",
        "similarQuestions": "[{\"title\": \"Decode Ways II\", \"titleSlug\": \"decode-ways-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Number of Ways to Separate Numbers\", \"titleSlug\": \"number-of-ways-to-separate-numbers\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Number of Texts\", \"titleSlug\": \"count-number-of-texts\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/decode-ways/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "92",
        "questionFrontendId": "92",
        "title": "Reverse Linked List II",
        "content": "<p>Given the <code>head</code> of a singly linked list and two integers <code>left</code> and <code>right</code> where <code>left &lt;= right</code>, reverse the nodes of the list from position <code>left</code> to position <code>right</code>, and return <em>the reversed list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], left = 2, right = 4\n<strong>Output:</strong> [1,4,3,2,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [5], left = 1, right = 1\n<strong>Output:</strong> [5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>n</code>.</li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>-500 &lt;= Node.val &lt;= 500</code></li>\n\t<li><code>1 &lt;= left &lt;= right &lt;= n</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you do it in one pass?",
        "likes": 12764,
        "dislikes": 773,
        "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"2.4M\", \"totalAcceptedRaw\": 1240580, \"totalSubmissionRaw\": 2443615, \"acRate\": \"50.8%\"}",
        "similarQuestions": "[{\"title\": \"Reverse Linked List\", \"titleSlug\": \"reverse-linked-list\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Linked List"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/reverse-linked-list-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "93",
        "questionFrontendId": "93",
        "title": "Restore IP Addresses",
        "content": "<p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p>\n\n<ul>\n\t<li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li>\n</ul>\n\n<p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into </em><code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;25525511135&quot;\n<strong>Output:</strong> [&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0000&quot;\n<strong>Output:</strong> [&quot;0.0.0.0&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;101023&quot;\n<strong>Output:</strong> [&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> consists of digits only.</li>\n</ul>\n",
        "likes": 5595,
        "dislikes": 818,
        "stats": "{\"totalAccepted\": \"597.1K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 597117, \"totalSubmissionRaw\": 1086128, \"acRate\": \"55.0%\"}",
        "similarQuestions": "[{\"title\": \"IP to CIDR\", \"titleSlug\": \"ip-to-cidr\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Backtracking"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n--- \n\n### Approach 1: Backtracking\n\n#### Intuition\n\n\nSince a valid IP address consists of 4 integers, that means we need to place 3 dots. We can try putting dots at all possible different positions using backtracking. If an invalid number is formed then we backtrack to try out another combination.\n\n> Backtracking can be defined as a general algorithmic technique that considers searching every possible combination to solve a computational problem. It incrementally builds candidates to the solution and abandons a candidate (\"backtracks\") when it determines that the candidate cannot lead to the solution.\n\nWe will recursively enumerate all the possibilities and whenever we get a new integer because of a dot (or 2 integers for the last dot), we check whether the integer(s) is valid, i.e the integer cannot have leading 0s other than being 0 itself and it's no larger than 255.\nThere are 3 possibilities to add each dot, namely it can be added after 1, 2, or 3 digits from the last dot or the beginning of the string, so there are at most $3 ^ 3 = 27$ possibilities to add all 3 dots.\n\nAn optimization is to return an empty result if the input string's length is longer than 12 since each integer can have 3 digits at most (any more and it would either have leading zeroes or be greater than 255).\n\nWe can create a helper function `valid(s, start, length)` to check whether the substring from index `start` to `start + length` is a valid number from range 0-255. The logic is to check both the conditions (the caller guarantees that the length is in the range of [1, 3]):\n\n1. If the substring's first character is `0` (i.e. `s[start]` is '0'), then `length` must be 1.\n2. If `length` is `3`, the substring should no larger than \"255\" lexically. If the length is 1 or 2 and the first case was not triggered, then it will be in the acceptable range.\n\n#### Algorithm\n\nCreate a function `helper` which takes the original string `s`, the processing index `startIndex` (i.e we only consider the substring starting from `startIndex` and the prefix part is already separated into valid integers.), a list of integers `dots` which saves distances for the dots we have added so far and a list of strings `ans` to save the answers.\n\n1. Set `remainingLength` to `length of s - startIndex` which is the string length we want to process.\n2. Set `remainingNumberOfIntegers` to `4 - dots.length`. This is how many integers we have left to form.\n3. Return if `remainingLength` is larger than `remainingNumberOfIntegers * 3` or smaller than `remainingNumberOfIntegers`, since each integer has 1-3 digits. Also note that this catches the case where `s.length() > 12` since at the very beginning `remainingLength` is `s.length()` and `remainingNumberOfIntegers` is 4.\n4. If `remainingNumberOfIntegers = 1`,\n    * if the last integer `s.substring(startIndex, startIndex + remainingLength)` is valid\n        * Create an empty string to save this answer using the following steps.\n        * Set `last` to `0`.\n        * Iterate over all elements `dot` in the list `dots`.\n            * Append `s.substring(last, last + dot)` and a '.' into the answer string.\n            * Increase `last` by `dot` and repeat these steps for each dot.\n       * Append `s.substring(last, s.length)`. This is the final integer after the last dot.\n       * Add the answer string into `ans`.\n    * Return.\n5. Iterate over `curPos` from `1` to `min(3, remainingLength)`. `curPos` is the number of digits we are including before placing a dot.\n    * Place a dot by adding `curPos` into `dots`.\n    * If the integer `s.substring(startIndex, startIndex + curPos)` is valid\n        * Call helper(s, startIndex + curPos, dots, ans)\n    * Remove the dot that we placed to backtrack.\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/DYStKNxi/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"DYStKNxi\"></iframe>\n\n\n#### Complexity Analysis\n\nLet's assume we need to separate the input string into $N$ integers, each integer is at most $M$ digits.\n\n* Time complexity: $O(M ^ N \\cdot N)$.\n\n There are at most $M ^ {N - 1}$ possibilities, and for each possibility checking whether all parts are valid takes $O(M \\cdot N)$ time, so the final time complexity is $O(M ^ {N - 1}) \\cdot O(M \\cdot N)$ = $O(M ^ N \\cdot N)$.\n\nFor this question, M = 3, N = 4, so the time complexity is $O(1)$.\n\n* Space complexity: $O(M \\cdot N)$.\n\n  For each possibility, we save (N - 1) numbers (the number of digits before each dot) which takes $O(N)$ space. And we need temporary space to save a solution before putting it into the answer list. The length of each solution string is $M \\cdot N + M - 1$ = $O(M \\cdot N)$, so the total space complexity is $O(M \\cdot N)$ if we don't take the output space into consideration.\n\nFor this question, M = 3, N = 4, so the space complexity is $O(1)$.\n\n\n### Approach 2: Iterative\n\n#### Intuition\nWe need to separate the input string into 4 integers, so we can enumerate the length of the first 3 integers, `len1`, `len2`, `len3`. We could iterate over `len1`, `len2`, `len3` with 3 nested loops and the last integer is the remaining part after separating out the first 3.\n\nWe can make the ranges of `len1`, `len2`, `len3` tighter:\n\n* `len1` should be in the range `[max(1, s.length() - 9), min(3, s.length() - 3]` since we need to separate 3 more integers after it and the length of each integer is in [1..3].\n* Similarly, `len2` should be in the range `[max(1, s.length() - len1 - 6, min(3, s.length() - len1 - 2]`\n* `len3` should be in the range `[max(1, s.length() - len1 - len2 - 3), min(3, s.length() - len1 - len2 - 1]`\n\nIn this way, the last part's length is always in the range of `[1..3]`, then we can split each substring out based on the lengths and check whether they are valid. Each integer can be validated before starting the loop of the next part to prevent wasting time.\n\n\n#### Algorithm\n\n1. Initialize an array of strings `ans`.\n2. Iterate over the range of `len1`, the length of the first integer.\n    * If the first integer is valid, then we iterate over `len2`'s range. \n        * If the second integer is also valid, then we iterate over `len3`'s range.\n           * If both third and fourth integers are valid, concatenate all four integers together with a character `'.'` between any 2 neighbors, and add the result string to `ans`.\n3. Return `ans`.\n\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/mcmi5hLS/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"mcmi5hLS\"></iframe>\n\n\n#### Complexity Analysis\n\n\nLet's assume we need to separate the input string into $N$ integers, each integer is at most $M$ digits.\n\n* Time complexity: $O(M ^ N \\cdot N)$.\n\n  We have $(N - 1)$ nested loops and each of them iterates at most $M$ times, so the total number of iterations is at most  $M ^ {N - 1}$ .\n\n  In each iteration we split $N$ substrings out to check whether they are valid, each substring's length is at most $M$, so the time complexity to separate out all of them is $O(M \\cdot N)$.\n\nFor this question, M = 3, N = 4, so the time complexity is $O(1)$.\n\n* Space complexity: $O(M \\cdot N)$.\n \nThe algorithm saves (N - 1) numbers (the number of digits before each dot) which takes $O(N)$ space. And we need temporary space to save a solution before putting it into the answer list. The length of each solution string is $M \\cdot N + M - 1$ = $O(M \\cdot N)$, so the total space complexity is $O(M \\cdot N)$ if we don't take the output space into consideration.\n\nFor this question, M = 3, N = 4, so the space complexity is $O(1)$.\n\n---"
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/restore-ip-addresses/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "94",
        "questionFrontendId": "94",
        "title": "Binary Tree Inorder Traversal",
        "content": "<p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,null,2,3]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,3,2]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png\" style=\"width: 200px; height: 264px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[4,2,6,5,7,1,3,9,8]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/tree_2.png\" style=\"width: 350px; height: 286px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = []</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?",
        "likes": 14712,
        "dislikes": 882,
        "stats": "{\"totalAccepted\": \"3.5M\", \"totalSubmission\": \"4.4M\", \"totalAcceptedRaw\": 3514425, \"totalSubmissionRaw\": 4417878, \"acRate\": \"79.6%\"}",
        "similarQuestions": "[{\"title\": \"Validate Binary Search Tree\", \"titleSlug\": \"validate-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Preorder Traversal\", \"titleSlug\": \"binary-tree-preorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Postorder Traversal\", \"titleSlug\": \"binary-tree-postorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Binary Search Tree Iterator\", \"titleSlug\": \"binary-search-tree-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Kth Smallest Element in a BST\", \"titleSlug\": \"kth-smallest-element-in-a-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Closest Binary Search Tree Value II\", \"titleSlug\": \"closest-binary-search-tree-value-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Inorder Successor in BST\", \"titleSlug\": \"inorder-successor-in-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Convert Binary Search Tree to Sorted Doubly Linked List\", \"titleSlug\": \"convert-binary-search-tree-to-sorted-doubly-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Distance Between BST Nodes\", \"titleSlug\": \"minimum-distance-between-bst-nodes\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Stack"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n### Approach 1: Recursive Approach\n\nThe first method to solve this problem is using recursion. This is the classical method and is straightforward. We can define a helper function to implement recursion.\n\n<iframe src=\"https://leetcode.com/playground/E5pBkUup/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"E5pBkUup\"></iframe>\n\n**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\n  - The time complexity is $$O(n)$$ because the recursive function is $$T(n) = 2 \\cdot T(n/2)+1$$.\n\nSpace complexity: $$O(n)$$\n\n  - The worst case space required is $$O(n)$$, and in the average case it's $$O(\\log n)$$ where $$n$$ is number of nodes.\n  \n<br />\n\n---\n\n### Approach 2: Iterating method using Stack\n\nThe strategy is very similiar to the first method, the different is using stack.\n\nHere is an illustration:\n\n!?!../Documents/94_Binary.json:1000,563!?!\n\n<iframe src=\"https://leetcode.com/playground/9k44r9CB/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"9k44r9CB\"></iframe>\n\n**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\nSpace complexity: $$O(n)$$\n\n<br />\n\n---\n\n### Approach 3: Morris Traversal\n\n\nIn this method, we have to use a new data structure - Threaded Binary Tree, and the strategy is as follows:\n\n\n>Step 1: Initialize current as root\n>\n>Step 2: While current is not NULL,\n>\n>     If current does not have left child\n>\n>         a. Add current\u2019s value\n>\n>         b. Go to the right, i.e., current = current.right\n>\n>     Else\n>\n>         a. In current's left subtree, make current the right child of the rightmost node\n>\n>         b. Go to this left child, i.e., current = current.left\n\n\nFor example:\n```\n\n          1\n        /   \\\n       2     3\n      / \\   /\n     4   5 6\n\n```\nFirst, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current's left subtree is\n\n```\n         2\n        / \\\n       4   5\n```\n So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = current.left (current = 2).\nThe tree now looks like:\n```\n         2\n        / \\\n       4   5\n            \\\n             1\n              \\\n               3\n              /\n             6\n```\nFor current 2, which has left child 4, we can continue with the same process as we did above\n```\n        4\n         \\\n          2\n           \\\n            5\n             \\\n              1\n               \\\n                3\n               /\n              6\n```\n then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above.\nFinally, the inorder traversal is [4,2,5,1,6,3].\n\nFor more details, please check\n[Threaded binary tree](https://en.wikipedia.org/wiki/Threaded_binary_tree) and\n[Explanation of Morris Method](https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion)\n\n\n<iframe src=\"https://leetcode.com/playground/fVkds6Bx/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"fVkds6Bx\"></iframe>\n\n**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\n  - To prove that the time complexity is $$O(n)$$, the biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree. Intuitively, the complexity is $$O(n \\log n)$$, because to find the predecessor node for a single node related to the height of the tree. But in fact, finding the predecessor nodes for all nodes only needs $$O(n)$$ time. Because a binary Tree with $$n$$ nodes has $$n-1$$ edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node. So the complexity is $$O(n)$$.\n\nSpace complexity: $$O(1)$$\n\n  - Extra space is only allocated for the ArrayList of size $$n$$, however the output does not count towards the space complexity."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "95",
        "questionFrontendId": "95",
        "title": "Unique Binary Search Trees II",
        "content": "<p>Given an integer <code>n</code>, return <em>all the structurally unique <strong>BST&#39;</strong>s (binary search trees), which has exactly </em><code>n</code><em> nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>. Return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" style=\"width: 600px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "likes": 7914,
        "dislikes": 581,
        "stats": "{\"totalAccepted\": \"557.2K\", \"totalSubmission\": \"903.4K\", \"totalAcceptedRaw\": 557207, \"totalSubmissionRaw\": 903436, \"acRate\": \"61.7%\"}",
        "similarQuestions": "[{\"title\": \"Unique Binary Search Trees\", \"titleSlug\": \"unique-binary-search-trees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Different Ways to Add Parentheses\", \"titleSlug\": \"different-ways-to-add-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Backtracking"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": true,
          "content": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nGiven an integer `n`, our task is to return all unique BSTs (binary search trees) that have exactly `n` nodes of unique values from `1` to `n`.\n\n---\n\n### Approach 1: Recursive Dynamic Programming\n\n#### Intuition\n\nIn each node of a binary search tree (BST), all values in the left subtree are smaller and all values in the right subtree are greater.\n\nTo find all the possible permutations of BSTs with `n` nodes, we can lock one node as the `root` node and split `n - 1` nodes between the left and right subtrees in all the possible ways. Let's say we place a node with value `i` as the root node and place `i - 1` nodes having values from `1` to `i - 1` in the left subtree. (If `i == 1`, the left child is null). Similarly, we place the remaining `n - i` nodes having values from `i + 1` to `n` in the right subtree. (If `i == n`, the right child is null).\n\nNow, we create a list of nodes called `leftSubTrees` for all the possible BSTs that could be the left subtree. Similarly, we create a list of nodes called `rightSubTrees` for all the BSTs that could be the right subtree. \n\n> In a BST, every subtree is also a BST.\n\nWe iterate over both the lists and for each node pair `l` in `leftSubTrees` and `r` in `rightSubTrees`, we create a new `root` node with value `i` and set the left and right child of `root` to `l` and `r` respectively to form all the BSTs with the root node as `i`.\n\nWe can iterate over the root's value from `i = 1` to `n` and repeat the process for each root value to get all the BSTs.\n\nYou may notice that the subproblem of finding the arrays `leftSubTrees` and `rightSubTrees` are similar to the original problem. We can implement this approach using recursion as we are breaking down a problem with `n` nodes to smaller, repetitive subproblems with `i - 1` and `n - i` nodes (for `i = 1` till `n`) to compute the answer for `n` nodes. We only need the range of node values as the parameters to create the BSTs with nodes having values in that range.\n\nWe implement a recursive function `allPossibleBST(start, end)` where `start` and `end` correspond to the range of node values that should be present in the BSTs created by this call. For a root node with value `i`, we will find all the left subtrees using `leftSubTrees = allPossibleBST(start, i - 1)` and also compute all the right subtrees using `rightSubTrees = allPossibleBST(i + 1, right)`. Finally, we iterate over all pairs between `leftSubTrees` and `rightSubTrees` and create a new root with value `i` for each pair.\n\nThe base case of this function is when `start > end`. We have no values in our range and thus we will return `null` (an empty tree).\n\nHere is a visual representation of the recursion tree with `3` nodes:\n\n![img](../Figures/95/95-1.png)\n\nSeveral subproblems, such as `allPossibleBST(1, 1)`, `allPossibleBST(3, 3)`, etc., are solved multiple times in the small partial recursion tree shown above. If we draw the entire recursion tree, we can see that there are many subproblems that are solved repeatedly.\n\nTo avoid this issue, we store the solution of the subproblem in a hashmap that stores the mapping from a range of nodes values to the list of root nodes of all possible BSTs that can be formed with the same number of nodes. When we encounter the same subproblem again, we simply refer to this map to get the required list of `TreeNode`. This is called **memoization**.\n\n#### Algorithm\n\n1. Create a hash map `memo` where `memo[(start, end)]` contains the list of root nodes of all possible BSTs with the range of node values from `start` to `end`.\n2. We implement a recursive function `allPossibleBST` which takes the starting range of node values `start`, ending range `end`, and `memo` as parameters. It returns a list of `TreeNode` corresponding to all the BSTs that can be formed with this range of node values. We call `allPossibleBST(1, n, memo)` and perform the following:\n    - We declare a list of `TreeNode` called `res` to store the list of root nodes of all possible BSTs.\n    - If `start > end`, we push `null` to `res` and return it.\n    - If we already have solved this subproblem, i.e., `memo` contains the pair `(start, end)`, we return `memo[(start, end)]`.\n    - Select the root node value from `i = start` to `end` incrementing `i` by `1` after each iteration. We recursively call `leftSubtrees = llPossibleBST(start, i - 1, memo)` and `rightSubTrees = allPossibleBST(i + 1, end, memo)`. We iterate over all pairs between `leftSubtrees` and `rightSubTrees` and create a new root with value `i` for each pair. We push `root` of the new formed BST into `res`.\n    - Set `memo[(start, end)] = res` and return `res`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/FiZegYw8/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"FiZegYw8\"></iframe>\n\n#### Complexity Analysis\n\nNote, the time and space complexity of this problem is difficult to derive. In an interview, you should do your best to find an upper bound. The level of analysis here would not be expected in an interview.\n\nThe number of unique BSTs that can be formed with `n` nodes is $G(n)$ where $G(n)$ is the $n^{th}$ [Catalan number](https://en.wikipedia.org/wiki/Catalan_number). $G(n) = O(\\dfrac{4^{n}}{n^{1.5}})$.\n\n* Time complexity: $O(\\dfrac{4^n}{\\sqrt{n}})$.\n    - There are $G(n) = \\dfrac{4^n}{n^{1.5}}$ BSTs in our answer. Each of these BSTs has $n$ nodes, so it cost us $O(n)$ to build each one. This gives us a time complexity of $O(n \\cdot G(n)) = O(\\dfrac{4^n}{\\sqrt{n}})$.\n\n* Space complexity: $O(\\sum_{k=1}^{n}{[(n - k + 1) \\cdot  \\dfrac{4^k}{\\sqrt{k}}]})$.\n\n    We use some space for the recursion call stack, but the majority of the space used by the algorithm is storing the lists of BSTs in `memo`. Let's analyze how many nodes are stored in `memo`.\n\n    The number of nodes in a range `start, end` is `end - start + 1`. Let $k = \\text{end} - \\text{start} + 1$ represent this formula.\n\n    There are $n$ states `start, end` with one node, that is $k = 1$.\n\n    There are $n - 1$ states `start, end` with two nodes, that is $k = 2$.\n\n    There are $n - 2$ states `start, end` with three nodes, that is $k = 3$.\n\n    This continues until there is only one state with $n$ nodes (the original input). In general, a value of $k$ has $n - k + 1$ states.\n\n    For a given state with value $k$, there are $G(k) = \\dfrac{4^k}{k^{1.5}}$ BSTs. Each of these BSTs has $k$ nodes, and thus takes up $k \\cdot G(k) = \\dfrac{4^k}{\\sqrt{k}}$ space in `memo`.\n\n    A given value $k$ has $n - k + 1$ states and thus takes up $(n - k + 1) \\cdot  \\dfrac{4^k}{\\sqrt{k}}$ space. In our algorithm, $k$ ranges from $1$ to $n$.\n\n    The space complexity is the summation for all values of $k$:\n\n    $\\Large{\\sum_{k=1}^{n}{[(n - k + 1) \\cdot  \\dfrac{4^k}{\\sqrt{k}}]}}$\n\n    This is a difficult sum to compute and involves higher-level mathematics. Using a program like WolframAlpha, we find that the sum is equal to:\n\n    $4^{1 + n} \\cdot \\Phi(4, -0.5, 1 + n) - 4^{1 + n} \\cdot (1 + n) \\cdot \\Phi(4, 0.5, 1 + n) - \\text{Li}_{-0.5}(4) + \\text{Li}_{0.5}(4) + n \\cdot \\text{Li}_{0.5}(4)$\n\n    Where $\\Phi$ is the [Lerch transcendent](https://en.wikipedia.org/wiki/Lerch_zeta_function) and $\\text{Li}_n(x)$ is the [polylogarithm function](https://en.wikipedia.org/wiki/Polylogarithm). Needless to say, computing this sum by hand is not necessary in an interview. Even reaching the summation expression would likely impress any interviewer.\n\n---\n\n### Approach 2: Iterative Dynamic Programming\n\n#### Intuition\n\nWe used memoization in the preceding approach to store the answers to subproblems in order to solve a larger problem. We can also use a bottom-up approach to solve such problems without using recursion. We build answers to subproblems iteratively first, then use them to build answers to larger problems.\n\nWe create a 3D list `dp[n + 1][n + 1]` where `dp[i][j]` will store a list of all BSTs that have node values ranging from `i` to `j`. Note that `dp[i][j] = allPossibleBST(i, j)` from the previous approach.\n\nWhen `i = j`, the range contains only one node with value `i`. We push a single node with value `i` in the list `dp[i][i]` for all the values of `i` from `1` to `n`. This acts as the base case of our solution while we move in bottom to top manner.\n\nWe form the answer with a smaller number of nodes having consecutive node values and move on to form answers for a bigger number of nodes. We run an outer loop from `numberOfNodes = 2` to `numberOfNodes = n` incrementing `numberOfNodes` by `1` after each iteration. This loop controls the total number of nodes under consideration.\n\nWe further need to choose a node value we start with. Let's call it `start`. As we have `numberOfNodes` nodes under consideration with consecutive values, the maximum node value in such a BST would be `end = start + numberOfNodes - 1`. We will move `start` from `1` to `n - numberOfNodes + 1`.\n\nNow we have the `start` value and the `end` value, we can implement the same logic that we did in the `allPossibleBST` function from the previous approach. Lock a value `i`, find all left and right subtrees, and then iterate over each `left, right` pair and create a new root with value `i` for each pair.\n\nAs we move from bottom to top, we will have a list of all the root nodes for all BSTs for every range of node values with lesser nodes.\n\nLocking a value `i` as the root node, we can find all left subtrees in `dp[start][i - 1]` and all right subtrees in `dp[i + 1][end]`. If `i == start`, the left subtree would be empty. Similarly, if `i == end`, the right subtree would be empty. We can handle these cases separately.\n\nWe run an outer loop from `numberOfNodes = 2` to `n`. We run an inner loop that selects the starting node value. It runs from `start = 1` to `n - numberOfNodes + 1`. We define `end = start + numberOfNodes - 1`. We run a third nested loop that selects the root of the BSTs under consideration. It runs from `i = start` to `end`.\n\nWe then iterate over the both the lists of left and right subtrees. For each root node `l` of the left subtree and `r` of the right subtree, we create a new `root` node with value `i` and set the left and right child to `l` and `r` respectively to form all the BSTs with root node as `i`. We also push each BST into `dp[start][end]` to be used later to build answer for other `dp` states with larger number of nodes.\n\n#### Algorithm\n\n1. Create a 3D list `dp[n + 1][n + 1]` where `dp[i][j]` will store a list of root nodes for all possible BSTs using `j - i + 1` nodes with values from `i` to `j` nodes.\n2. We initialize each list `dp[i][i]` to a `TreeNode` having value `i` for `i = 0` to `n`.\n3. Iterate from `numberOfNodes = 2` till `numberOfNodes = n` incrementing `numberOfNodes` by `1` after each iteration. We start an inner loop from `start = 1` to `n - numberOfNodes + 1` incrementing `start` by `1`. We create an integer variable `end = start + numberOfNodes - 1` which stores the highest node value of the BSTs that will be formed. We run another loop from `i = start` to `end` to use all the permutations as the root node value. We perform the following in this loop:\n    - We create a list of `TreeNode` called `leftSubtrees` which will store all the BSTs that can be formed with node values from `start` to `i - 1`. If `i == start`, we just add `null` to `leftSubtrees`, else `leftSubtrees == dp[start][i - 1]`.\n    - Similarly, we create a list of `TreeNode` called `rightSubtrees` which will store all the BSTs that can be formed with node values from `i + 1` to `end`. If `i == end`, we just add `null` to `rightSubtrees`, else `rightSubtrees == dp[i + 1][end]`.\n    - We form a new BST by creating a new node which acts as a root node with value `i`. For each element `left` in `leftSubtrees` and `right` in `rightSubtrees`, we set `root.left = left` and `root.right = right`. Finally, we add `root` to `dp[start][end]`.\n4. Return `dp[1][n]`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/hj8MdGva/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"hj8MdGva\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $O(\\dfrac{4^n}{\\sqrt{n}})$.\n    - The time complexity of this approach will be similar to the **time complexity** of the first approach because we are iterating over the same `dp` states in bottom-up manner as compared to the previous approach where we used top-down approach with memoization.\n\n* Space complexity: $O(\\sum_{k=1}^{n}{[(n - k + 1) \\cdot  \\dfrac{4^k}{\\sqrt{k}}]})$.\n    - The space complexity would also be the number of BSTs stored in the `dp` list which is equal to the number of BSTs stored in `memo` in the worst-case. Hence, we have the same space complexity as the first approach.\n\n---\n\n### Approach 3: Dynamic Programming with Space Optimization\n\n#### Intuition\n\nWe used a 3D list where we used `dp[start][end]` to store all the BSTs having `end - start + 1` nodes with range from `start` to `end`. Let's think if we can reduce the 3D `dp` list to a 2D list.\n\nIf we compare all the BSTs that can be created from a set of consecutive values from `start` to `end` to those that can be created with the same number of nodes from a set of values starting at `1` and ending at `end - start + 1`, we will find that **the structure of all the BSTs created with the above two ranges would be identical**. The only difference is an offset of `start - 1` in the node values.\n\nHere's a visual representation of BSTs with 3 nodes from range `[1, 3]` and all BSTs with range `[4, 6]`:\n\n![img](../Figures/95/95-2.png)\n\nWe can see the structure of all the BSTs created with the above two ranges are identical.\n\nSo, we can just store the BSTs for all the ranges starting from `1` and add the offset to convert them to required ranges.\n\nWe create a 2D list `dp[n + 1]` where `dp[i]` will store a list of all BSTs with `i` nodes having values from `1` to `i`. `dp[n]` would be the answer to the problem. Similar to the above approach, we will move in bottom to top manner.\n\nWe push a `null` node (empty tree) to `dp[0]` which acts as the base case.\n\nTo get the list of root nodes for all possible BSTs with `numberOfNodes` nodes, we would split the `numberOfNodes` nodes with `i - 1` nodes with values `1` to `i - 1` in the left subtree, a root node with value `i` and the remaining `numberOfNodes - i` nodes with values `i + 1` to `numberOfNodes` in the right subtree where `1 <= i <= numberOfNodes`. Note that we do not need the starting of the range here, unlike the previous approach. It is always `1`. \n\nAs we are executing in bottom-up manner and figuring out the answer for `numberOfNodes` nodes, we will already have the list of root nodes for all BSTs with `i - 1` and `numberOfNodes - i` nodes (for all values of `i = 1` to `numberOfNodes`).\n\nHowever, you may realize that `dp[i - 1]` will give all the BSTs having values from `1` to `i - 1` which is exactly what we want but `dp[numberOfNodes - i]` will give all the BSTs having values from `1` to `numberOfNodes - i` which isn't what we want. We want the right subtree to have `numberOfNodes - i` nodes but the range of nodes should be from `i + 1` to `numberOfNodes`. If we add the offset `(i + 1) - 1 = i` to all the nodes, it would solve this as we would now have trees with `numberOfNodes - i` nodes from values `i + 1` to `numberOfNodes`. Let us form the BSTs now.\n\nSimilar to the previous approach, we create a new instance of `TreeNode` called `root` with the value `i`. We set the left child of `root` to an element in `dp[i - 1]`.\n\nNow, let's set the right child of `root`. We know every element in `dp[numberOfNodes - i]` is a root node that stores a BST with `numberOfNodes - 1` nodes having values from `1` to `numberOfNodes - i`. To set the right child of `root`, we create a new tree exactly similar to the tree stored by an element of `dp[numberOfNodes - i]` but increment all the node values of the new tree by `i`. We then set the right child of `root` to this newer tree.\n\nThe required tree with `i` offset can be created by using a recursive function `clone` in which we pass a `TreeNode node` which corresponds to an element in `dp[numberOfNodes - i]` and an integer `offset`. We create a new `TreeNode clonedNode` with value `node.val + offset`. We then recursively set the left and the right child of `clonedNode` by performing `clonedNode.left = clone(node.left, offset)` and `clonedNode.right = clone(node.right, offset)`. Finally, return `clonedNode`.\n\nIt is important to note that we are creating new trees to set the right child of `root` to preserve the original trees as it might be used directly (as `dp[i - 1]`) in some other iteration of `i` and `numberOfNodes`.\n\n#### Algorithm\n\n1. Create a list `dp[n + 1]` where `dp[i]` will store a list of root nodes for all possible BSTs using `i` nodes. We initialize each list `dp[i]` to an empty list for `i = 0` to `n`.\n2. We push a `null` node (empty tree) into `dp[0]` because with `n = 0` we can't have any BST. This forms the base case.\n3. Iterate from `numberOfNodes = 1` till `numberOfNodes = n` incrementing `numberOfNodes` by `1` after each iteration. We start an inner loop from `i = 1` to `numberOfNodes` incrementing `i` by `1`. We perform the following in this loop:\n    - Create a variable `j = numberOfNodes - i - 1`. It presents the number of nodes in the right subtree under consideration.\n    - We can form a new BST by creating a new node which acts as a root node with value `i`. We assign its left child to any element in `dp[i]` and right child to a new tree where tree is similar to an element in `dp[j]` but all node values are incremented by `i`. As a result, we need two loops to iterate through the lists `dp[i]` and `dp[j]`. We create a new `root` node with value `i`. For each element `left` in `dp[i]` and `right` in `dp[j]`, we set `root.left = left` and `root.right = clone(right, i)`. Finally, we add `root` to `dp[numberOfNodes]`.\n4. Return `dp[n]`.\n\n#### Implementation\n\n<iframe src=\"https://leetcode.com/playground/a8x29E6y/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"a8x29E6y\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $O(\\dfrac{4^n}{\\sqrt{n}})$.\n    - In this approach we are not storing all the BSTs with all the ranges. We are just storing BSTs starting from range `1`. However, we are creating all the BSTs for all the ranges from `[start, end]` (for `1 <= start, end  <= 1`) using the `clone` method by iterating over the BSTs starting with range `1`.\n    - As a result, the time complexity should be similar to the previous approach as we are generating the same number of BSTs.\n\n* Space complexity: $O(\\sum_{k=1}^{n}\\dfrac{4^k}{{\\sqrt{k}}})$.\n    - For any state `dp[k]`, we are storing all the BSTs that can be formed with $k$ nodes. We know there are $G(k)$ BSTs that can be formed with $k$ nodes. As we have $1$ to $n$ states, the total space consumed would be $O(\\sum_{k=1}^{n} k \\cdot G(k))$ = $O(\\sum_{k=1}^{n}\\dfrac{4^k}{{\\sqrt{k}}})$."
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "96",
        "questionFrontendId": "96",
        "title": "Unique Binary Search Trees",
        "content": "<p>Given an integer <code>n</code>, return <em>the number of structurally unique <strong>BST&#39;</strong>s (binary search trees) which has exactly </em><code>n</code><em> nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" style=\"width: 600px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 5\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 19</code></li>\n</ul>\n",
        "likes": 10939,
        "dislikes": 444,
        "stats": "{\"totalAccepted\": \"830.4K\", \"totalSubmission\": \"1.3M\", \"totalAcceptedRaw\": 830399, \"totalSubmissionRaw\": 1314732, \"acRate\": \"63.2%\"}",
        "similarQuestions": "[{\"title\": \"Unique Binary Search Trees II\", \"titleSlug\": \"unique-binary-search-trees-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Math"
          },
          {
            "name": "Dynamic Programming"
          },
          {
            "name": "Tree"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/unique-binary-search-trees/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "97",
        "questionFrontendId": "97",
        "title": "Interleaving String",
        "content": "<p>Given strings <code>s1</code>, <code>s2</code>, and <code>s3</code>, find whether <code>s3</code> is formed by an <strong>interleaving</strong> of <code>s1</code> and <code>s2</code>.</p>\n\n<p>An <strong>interleaving</strong> of two strings <code>s</code> and <code>t</code> is a configuration where <code>s</code> and <code>t</code> are divided into <code>n</code> and <code>m</code> <span data-keyword=\"substring-nonempty\">substrings</span> respectively, such that:</p>\n\n<ul>\n\t<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>\n\t<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>\n\t<li><code>|n - m| &lt;= 1</code></li>\n\t<li>The <strong>interleaving</strong> is <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> or <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>\n</ul>\n\n<p><strong>Note:</strong> <code>a + b</code> is the concatenation of strings <code>a</code> and <code>b</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg\" style=\"width: 561px; height: 203px;\" />\n<pre>\n<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> One way to obtain s3 is:\nSplit s1 into s1 = &quot;aa&quot; + &quot;bc&quot; + &quot;c&quot;, and s2 into s2 = &quot;dbbc&quot; + &quot;a&quot;.\nInterleaving the two splits, we get &quot;aa&quot; + &quot;dbbc&quot; + &quot;bc&quot; + &quot;a&quot; + &quot;c&quot; = &quot;aadbbcbcac&quot;.\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Notice how it is impossible to interleave s2 with any other string to obtain s3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= s3.length &lt;= 200</code></li>\n\t<li><code>s1</code>, <code>s2</code>, and <code>s3</code> consist of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it using only <code>O(s2.length)</code> additional memory space?</p>\n",
        "likes": 8782,
        "dislikes": 548,
        "stats": "{\"totalAccepted\": \"743.5K\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 743461, \"totalSubmissionRaw\": 1716973, \"acRate\": \"43.3%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "String"
          },
          {
            "name": "Dynamic Programming"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/interleaving-string/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "98",
        "questionFrontendId": "98",
        "title": "Validate Binary Search Tree",
        "content": "<p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>\n\n<p>A <strong>valid BST</strong> is defined as follows:</p>\n\n<ul>\n\t<li>The left <span data-keyword=\"subtree\">subtree</span> of a node contains only nodes with keys&nbsp;<strong>strictly less than</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>strictly greater than</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\" style=\"width: 302px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\" style=\"width: 422px; height: 292px;\" />\n<pre>\n<strong>Input:</strong> root = [5,1,4,null,null,3,6]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The root node&#39;s value is 5 but its right child&#39;s value is 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "likes": 18174,
        "dislikes": 1440,
        "stats": "{\"totalAccepted\": \"3.2M\", \"totalSubmission\": \"9M\", \"totalAcceptedRaw\": 3179592, \"totalSubmissionRaw\": 9034426, \"acRate\": \"35.2%\"}",
        "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Mode in Binary Search Tree\", \"titleSlug\": \"find-mode-in-binary-search-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/validate-binary-search-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "99",
        "questionFrontendId": "99",
        "title": "Recover Binary Search Tree",
        "content": "<p>You are given the <code>root</code> of a binary search tree (BST), where the values of <strong>exactly</strong> two nodes of the tree were swapped by mistake. <em>Recover the tree without changing its structure</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg\" style=\"width: 422px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,null,null,2]\n<strong>Output:</strong> [3,1,null,null,2]\n<strong>Explanation:</strong> 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg\" style=\"width: 581px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,1,4,null,null,2]\n<strong>Output:</strong> [2,1,4,null,null,3]\n<strong>Explanation:</strong> 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 1000]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> A solution using <code>O(n)</code> space is pretty straight-forward. Could you devise a constant <code>O(1)</code> space solution?",
        "likes": 8518,
        "dislikes": 287,
        "stats": "{\"totalAccepted\": \"625.3K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 625285, \"totalSubmissionRaw\": 1070296, \"acRate\": \"58.4%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Binary Search Tree"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Medium",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": false,
        "url": "https://leetcode.com/problems/recover-binary-search-tree/"
      }
    }
  },
  {
    "data": {
      "question": {
        "questionId": "100",
        "questionFrontendId": "100",
        "title": "Same Tree",
        "content": "<p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p>\n\n<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\" style=\"width: 622px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> p = [1,2,3], q = [1,2,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\" style=\"width: 382px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> p = [1,2], q = [1,null,2]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\" style=\"width: 622px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> p = [1,2,1], q = [1,1,2]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in both trees is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "likes": 12707,
        "dislikes": 291,
        "stats": "{\"totalAccepted\": \"3.2M\", \"totalSubmission\": \"4.8M\", \"totalAcceptedRaw\": 3216700, \"totalSubmissionRaw\": 4844450, \"acRate\": \"66.4%\"}",
        "similarQuestions": "[]",
        "categoryTitle": "Algorithms",
        "hints": [],
        "topicTags": [
          {
            "name": "Tree"
          },
          {
            "name": "Depth-First Search"
          },
          {
            "name": "Breadth-First Search"
          },
          {
            "name": "Binary Tree"
          }
        ],
        "companyTags": null,
        "difficulty": "Easy",
        "isPaidOnly": false,
        "solution": {
          "canSeeDetail": false,
          "content": null
        },
        "hasSolution": true,
        "hasVideoSolution": true,
        "url": "https://leetcode.com/problems/same-tree/"
      }
    }
  }
]